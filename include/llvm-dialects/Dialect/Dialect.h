/*
 * Copyright (c) 2022 Advanced Micro Devices, Inc. All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

#pragma once

#include "llvm/ADT/ArrayRef.h"
#include "llvm/ADT/SmallVector.h"
#include "llvm/Support/TrailingObjects.h"

namespace llvm {
class CallInst;
class Function;
class LLVMContext;
} // namespace llvm

namespace llvm_dialects {

class ContextExtensionBase;
class Dialect;
class DialectContext;
template <typename ExtensionT, typename DialectT>
class DialectExtensionRegistration;

struct DialectDescriptor {
  unsigned index;
  Dialect* (*make)(llvm::LLVMContext& context);
};

/// Base for dialect classes generated by TableGen. Dialect classes are used to define dialect sets
/// for setting up dialect-augmented LLVMContexts. An instance of the dialect classes is created
/// per LLVMContext for which the dialect is enabled.
class Dialect {
  friend DialectContext;

  llvm::LLVMContext& m_context;

protected:
  virtual void anchor();

  // There is a global instance of Key for every dialect class. Dialects have a globally unique ID
  // that is assigned at runtime.
  class Key {
    unsigned m_index;

  public:
    Key();
    ~Key();

    unsigned getIndex() const {return m_index;}

    static llvm::SmallVectorImpl<Key*>& getRegisteredKeys();
  };

  explicit Dialect(llvm::LLVMContext& context) : m_context(context) {}
  virtual ~Dialect() = default;

public:
  llvm::LLVMContext& getContext() const {return m_context;}
};

/// Augmentation of LLVMContext with zero or more dialects.
///
/// Users of this library must create exactly one DialectContext together with
/// the LLVMContext. The DialectContext must be destroyed again before the
/// LLVMContext.
///
/// @example
///   LLVMContext context;
///   auto dialectContext = DialectContext::make<Dialect1, Dialect2, ...>(context);
///
class DialectContext final
    : private llvm::TrailingObjects<DialectContext, Dialect *,
                                    std::unique_ptr<ContextExtensionBase>> {
  friend llvm::TrailingObjects<DialectContext, Dialect *,
                               std::unique_ptr<ContextExtensionBase>>;

  llvm::LLVMContext& m_llvmContext;
  unsigned m_dialectArraySize;
  unsigned m_extensionArraySize;

  DialectContext(llvm::LLVMContext &context, unsigned dialectArraySize,
                 unsigned extensionArraySize);

  size_t numTrailingObjects(OverloadToken<Dialect *>) const {
    return m_dialectArraySize;
  }
  size_t numTrailingObjects(
      OverloadToken<std::unique_ptr<ContextExtensionBase>>) const {
    return m_extensionArraySize;
  }

public:
  ~DialectContext();

  void operator delete(void *ctx);

  // Placement deletes are called if the constructor throws (shouldn't happen,
  // but let's be thorough).
  void operator delete(void *ctx, unsigned) {
    DialectContext::operator delete(ctx);
  }
  void operator delete(void *ctx, unsigned, unsigned) {
    DialectContext::operator delete(ctx);
  }

  /// Get the DialectContext associated to the given LLVM context.
  ///
  /// It is an error to call this function for an LLVMContext for which no
  /// DialectContext was created.
  static DialectContext& get(llvm::LLVMContext& context);

  template <typename... DialectsT>
  static std::unique_ptr<DialectContext> make(llvm::LLVMContext& context) {
    std::array<DialectDescriptor, sizeof...(DialectsT)> descs{{DialectsT::getDescriptor()...}};
    return make(context, descs);
  }
  static std::unique_ptr<DialectContext> make(llvm::LLVMContext& context,
                                              llvm::ArrayRef<DialectDescriptor> dialects);

  llvm::LLVMContext& getContext() const {return m_llvmContext;}

  template <typename DialectT>
  DialectT& getDialect() const {
    Dialect* dialect = getTrailingObjects<Dialect*>()[DialectT::getIndex()];
    assert(dialect != nullptr);
    return *static_cast<DialectT*>(dialect);
  }

  template <typename DialectT>
  bool hasDialect() const {
    return getTrailingObjects<Dialect*>()[DialectT::getIndex()];
  }

  bool hasDialectByIndex(unsigned index) const {
    if (index >= m_dialectArraySize)
      return false;
    return getTrailingObjects<Dialect *>()[index] != nullptr;
  }

  std::unique_ptr<ContextExtensionBase> &getExtensionSlot(unsigned index) {
    return getTrailingObjects<std::unique_ptr<ContextExtensionBase>>()[index];
  }
};

/// CRTP helper for the TableGen-generated dialect classes.
template <typename DialectT>
class DialectImpl : public Dialect {
  friend class DialectContext;

  static unsigned getIndex() {return DialectT::getKey().getIndex();}

protected:
  explicit DialectImpl(llvm::LLVMContext& context) : Dialect(context) {}

public:
  static DialectT& get(llvm::LLVMContext& context) {
    return DialectContext::get(context).getDialect<DialectT>();
  }
  static bool hasDialect(llvm::LLVMContext& context) {
    return DialectContext::get(context).hasDialect<DialectT>();
  }
  static DialectDescriptor getDescriptor() {
    DialectDescriptor desc;
    desc.index = getIndex();
    desc.make = &DialectT::make;
    return desc;
  }
};

namespace detail {

class DialectExtensionPointBase {
protected:
  /// Extensions indexed by the dialect ID.
  llvm::SmallVector<const void *> m_extensions;

  void add(unsigned index, const void *extension);
  void clear(unsigned index);
};

} // namespace detail

template <typename ExtensionT>
class DialectExtensionPoint : public detail::DialectExtensionPointBase {
  template <typename T, typename U> friend class DialectExtensionRegistration;

  void add(unsigned index, const ExtensionT *extension) {
    DialectExtensionPointBase::add(index,
                                   reinterpret_cast<const void *>(extension));
  }

  void clear(unsigned index) { DialectExtensionPointBase::clear(index); }

public:
  /// Retrieve a list of extensions for the dialects registered with the given
  /// context.
  llvm::SmallVector<const ExtensionT *> getExtensions(DialectContext &context) {
    llvm::SmallVector<const ExtensionT *> extensions;
    for (unsigned i = 0; i < m_extensions.size(); ++i) {
      if (m_extensions[i] && context.hasDialectByIndex(i))
        extensions.push_back(
            reinterpret_cast<const ExtensionT *>(m_extensions[i]));
    }
    return extensions;
  }

  llvm::SmallVector<const ExtensionT *>
  getExtensions(llvm::LLVMContext &context) {
    return getExtensions(DialectContext::get(context));
  }
};

/// Helper class for registering a dialect extension.
///
/// Instantiate a static global of this type to register a dialect's extension
/// for a given extension point.
template <typename ExtensionT, typename DialectT>
class DialectExtensionRegistration {
public:
  DialectExtensionRegistration(DialectExtensionPoint<ExtensionT> &point,
                               const ExtensionT *extension)
      : m_point(point) {
    m_point.add(DialectT::getKey().getIndex(), extension);
  }
  ~DialectExtensionRegistration() {
    m_point.clear(DialectT::getKey().getIndex());
  }

private:
  DialectExtensionPoint<ExtensionT> &m_point;
};

namespace detail {

bool isSimpleOperationDecl(const llvm::Function *fn, llvm::StringRef mnemonic);
bool isOverloadedOperationDecl(const llvm::Function *fn,
                               llvm::StringRef mnemonic);

bool isSimpleOperation(const llvm::CallInst *i, llvm::StringRef mnemonic);
bool isOverloadedOperation(const llvm::CallInst *i, llvm::StringRef mnemonic);
bool isOperationDecl(llvm::StringRef fn, bool isOverloaded,
                     llvm::StringRef mnemonic);

} // namespace detail

} // namespace llvm_dialects
