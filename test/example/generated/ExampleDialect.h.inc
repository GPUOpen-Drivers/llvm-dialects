// DO NOT EDIT! This file is automatically generated by llvm-dialects-tblgen.


#ifdef GET_INCLUDES
#undef GET_INCLUDES
#include "llvm-dialects/Dialect/Dialect.h"
#include "llvm/IR/DerivedTypes.h"
#include "llvm/IR/Instructions.h"

namespace llvm {
class raw_ostream;
template <typename T> class ArrayRef;
template <typename T> class iterator_range;
} // namespace llvm

namespace llvm_dialects {
class Builder;
} // namespace llvm_dialects
#endif // GET_INCLUDES

#ifdef GET_DIALECT_DECLS
#undef GET_DIALECT_DECLS

namespace xd::cpp {


    class ExampleDialect : public ::llvm_dialects::DialectImpl<ExampleDialect> {
      friend DialectImpl;
      friend ::llvm_dialects::DialectContext;

      void anchor() override;

    public:
      static Key& getKey();
      static bool isDialectOp(::llvm::CallInst& op);
      static bool isDialectOp(::llvm::Function& func);
      static bool isDialectOp(::llvm::StringRef funcName);

    private:
      ExampleDialect(::llvm::LLVMContext& context);

      static ::llvm_dialects::Dialect* make(::llvm::LLVMContext& context);
  
      public:
        ::llvm::AttributeList getAttributeList(size_t index) const {
          return m_attributeLists[index];
        }

      private:
        ::std::array<::llvm::AttributeList, 6> m_attributeLists;
    };

    class XdHandleType : public ::llvm::TargetExtType {
      static constexpr ::llvm::StringLiteral s_name{"xd.ir.handle"};

    public:
      static bool classof(const ::llvm::TargetExtType *t) {
        return t->getName() == s_name;
      }
      static bool classof(const ::llvm::Type* t) {
        return llvm::isa<::llvm::TargetExtType>(t) &&
                classof(llvm::cast<::llvm::TargetExtType>(t));
      }

      bool verifier(::llvm::raw_ostream &errs) const;

  static XdHandleType *get(::llvm::LLVMContext & ctx);

};


    class XdVectorType : public ::llvm::TargetExtType {
      static constexpr ::llvm::StringLiteral s_name{"xd.ir.vector"};

    public:
      static bool classof(const ::llvm::TargetExtType *t) {
        return t->getName() == s_name;
      }
      static bool classof(const ::llvm::Type* t) {
        return llvm::isa<::llvm::TargetExtType>(t) &&
                classof(llvm::cast<::llvm::TargetExtType>(t));
      }

      bool verifier(::llvm::raw_ostream &errs) const;

  static XdVectorType *get(VectorKind kind, ::llvm::Type * elementType, uint32_t numElements);

VectorKind getKind() const;
::llvm::Type * getElementType() const;
uint32_t getNumElements() const;
};


      class StreamReduceOp : public ::llvm::CallInst {
      public:
        static bool classof(const ::llvm::CallInst* i);
        static bool classof(const ::llvm::Value* v) {
          return ::llvm::isa<::llvm::CallInst>(v) &&
                 classof(::llvm::cast<::llvm::CallInst>(v));
        }
    ::llvm::Value * getPtr() const;
          void setPtr(::llvm::Value * ptr);
        ::llvm::Value * getCount() const;
          void setCount(::llvm::Value * count);
        ::llvm::Value * getInitial() const;
          void setInitial(::llvm::Value * initial);
        struct ArgumentIndex { enum Enum : uint32_t {
Ptr = 0,
Count = 1,
Initial = 2,
};};
      };
    
      /// Add32Op
/// add two numbers, and a little extra
/// 
///     For those times when you want a little extra, this operation adds two
///     numbers and puts a constant on top.
///   

      class Add32Op : public ::llvm::CallInst {
        static const ::llvm::StringLiteral s_name; //{"xd.ir.add32"};

      public:
        static bool classof(const ::llvm::CallInst* i) {
          return ::llvm_dialects::detail::isSimpleOperation(i, s_name);
        }
        static bool classof(const ::llvm::Value* v) {
          return ::llvm::isa<::llvm::CallInst>(v) &&
                 classof(::llvm::cast<::llvm::CallInst>(v));
        }
    static Add32Op* create(::llvm_dialects::Builder& b, ::llvm::Value * lhs, ::llvm::Value * rhs, uint32_t extra, const llvm::Twine &instName = "");

bool verifier(::llvm::raw_ostream &errs);

::llvm::Value * getLhs() const;
          void setLhs(::llvm::Value * lhs);
        ::llvm::Value * getRhs() const;
          void setRhs(::llvm::Value * rhs);
        uint32_t getExtra() const;
          void setExtra(uint32_t extra);
        struct ArgumentIndex { enum Enum : uint32_t {
Lhs = 0,
Rhs = 1,
Extra = 2,
};};
::llvm::Value * getResult();


      };
    
      /// CombineOp
/// combine two pieces of data
/// 
///     Longer description of... well, you know by now how this goes.
///   

      class CombineOp : public ::llvm::CallInst {
        static const ::llvm::StringLiteral s_name; //{"xd.ir.combine"};

      public:
        static bool classof(const ::llvm::CallInst* i) {
          return ::llvm_dialects::detail::isOverloadedOperation(i, s_name);
        }
        static bool classof(const ::llvm::Value* v) {
          return ::llvm::isa<::llvm::CallInst>(v) &&
                 classof(::llvm::cast<::llvm::CallInst>(v));
        }
    static CombineOp* create(::llvm_dialects::Builder& b, ::llvm::Value * lhs, ::llvm::Value * rhs, const llvm::Twine &instName = "");

bool verifier(::llvm::raw_ostream &errs);

::llvm::Value * getLhs() const;
          void setLhs(::llvm::Value * lhs);
        ::llvm::Value * getRhs() const;
          void setRhs(::llvm::Value * rhs);
        struct ArgumentIndex { enum Enum : uint32_t {
Lhs = 0,
Rhs = 1,
};};
::llvm::Value * getResult();


      };
    
      /// ExtractElementOp
/// extract an element from a vector
/// 
///     Return the element of `vector` with the given `index`.
///   

      class ExtractElementOp : public ::llvm::CallInst {
        static const ::llvm::StringLiteral s_name; //{"xd.ir.extractelement"};

      public:
        static bool classof(const ::llvm::CallInst* i) {
          return ::llvm_dialects::detail::isOverloadedOperation(i, s_name);
        }
        static bool classof(const ::llvm::Value* v) {
          return ::llvm::isa<::llvm::CallInst>(v) &&
                 classof(::llvm::cast<::llvm::CallInst>(v));
        }
    static ExtractElementOp* create(::llvm_dialects::Builder& b, ::llvm::Value * vector, ::llvm::Value * index, const llvm::Twine &instName = "");

bool verifier(::llvm::raw_ostream &errs);

::llvm::Value * getVector() const;
          void setVector(::llvm::Value * vector);
        ::llvm::Value * getIndex() const;
          void setIndex(::llvm::Value * index);
        struct ArgumentIndex { enum Enum : uint32_t {
Vector = 0,
Index = 1,
};};
::llvm::Value * getResult();


      };
    
      /// FromFixedVectorOp
/// convert <n x T> to our custom vector type
/// 
///     Demonstrate a more complex unification case.
///   

      class FromFixedVectorOp : public ::llvm::CallInst {
        static const ::llvm::StringLiteral s_name; //{"xd.ir.fromfixedvector"};

      public:
        static bool classof(const ::llvm::CallInst* i) {
          return ::llvm_dialects::detail::isOverloadedOperation(i, s_name);
        }
        static bool classof(const ::llvm::Value* v) {
          return ::llvm::isa<::llvm::CallInst>(v) &&
                 classof(::llvm::cast<::llvm::CallInst>(v));
        }
    static FromFixedVectorOp* create(::llvm_dialects::Builder& b, ::llvm::Type* resultType, ::llvm::Value * source, const llvm::Twine &instName = "");

bool verifier(::llvm::raw_ostream &errs);

::llvm::Value * getSource() const;
          void setSource(::llvm::Value * source);
        struct ArgumentIndex { enum Enum : uint32_t {
Source = 0,
};};
::llvm::Value * getResult();


      };
    
      /// HandleGetOp
/// obtain a handle
/// 
///     Use a dialect type without type arguments.
///   

      class HandleGetOp : public ::llvm::CallInst {
        static const ::llvm::StringLiteral s_name; //{"xd.ir.handle.get"};

      public:
        static bool classof(const ::llvm::CallInst* i) {
          return ::llvm_dialects::detail::isSimpleOperation(i, s_name);
        }
        static bool classof(const ::llvm::Value* v) {
          return ::llvm::isa<::llvm::CallInst>(v) &&
                 classof(::llvm::cast<::llvm::CallInst>(v));
        }
    static HandleGetOp* create(::llvm_dialects::Builder& b, const llvm::Twine &instName = "");

bool verifier(::llvm::raw_ostream &errs);


::llvm::Value * getResult();


      };
    
      /// IExtOp
/// custom ext operation that only works on integers
/// 
///     Demonstrates the use of the same unevaluatable `le` predicate in a valued
///     position.
///   

      class IExtOp : public ::llvm::CallInst {
        static const ::llvm::StringLiteral s_name; //{"xd.ir.iext"};

      public:
        static bool classof(const ::llvm::CallInst* i) {
          return ::llvm_dialects::detail::isOverloadedOperation(i, s_name);
        }
        static bool classof(const ::llvm::Value* v) {
          return ::llvm::isa<::llvm::CallInst>(v) &&
                 classof(::llvm::cast<::llvm::CallInst>(v));
        }
    static IExtOp* create(::llvm_dialects::Builder& b, ::llvm::Type* resultType, ::llvm::Value * source, const llvm::Twine &instName = "");

bool verifier(::llvm::raw_ostream &errs);

::llvm::Value * getSource() const;
          void setSource(::llvm::Value * source);
        struct ArgumentIndex { enum Enum : uint32_t {
Source = 0,
};};
::llvm::Value * getResult();


      };
    
      /// ITruncOp
/// custom trunc operation that only works on integers
/// 
///     Demonstrates the use of a predicate in an unvalued position.
///   

      class ITruncOp : public ::llvm::CallInst {
        static const ::llvm::StringLiteral s_name; //{"xd.ir.itrunc"};

      public:
        static bool classof(const ::llvm::CallInst* i) {
          return ::llvm_dialects::detail::isOverloadedOperation(i, s_name);
        }
        static bool classof(const ::llvm::Value* v) {
          return ::llvm::isa<::llvm::CallInst>(v) &&
                 classof(::llvm::cast<::llvm::CallInst>(v));
        }
    static ITruncOp* create(::llvm_dialects::Builder& b, ::llvm::Type* resultType, ::llvm::Value * source, const llvm::Twine &instName = "");

bool verifier(::llvm::raw_ostream &errs);

::llvm::Value * getSource() const;
          void setSource(::llvm::Value * source);
        struct ArgumentIndex { enum Enum : uint32_t {
Source = 0,
};};
::llvm::Value * getResult();


      };
    
      /// ImmutableOp
/// demonstrate how an argument will not get a setter method
/// 
///     Make an argument immutable
///   

      class ImmutableOp : public ::llvm::CallInst {
        static const ::llvm::StringLiteral s_name; //{"xd.ir.immutable.op"};

      public:
        static bool classof(const ::llvm::CallInst* i) {
          return ::llvm_dialects::detail::isSimpleOperation(i, s_name);
        }
        static bool classof(const ::llvm::Value* v) {
          return ::llvm::isa<::llvm::CallInst>(v) &&
                 classof(::llvm::cast<::llvm::CallInst>(v));
        }
    static ImmutableOp* create(::llvm_dialects::Builder& b, bool val, const llvm::Twine &instName = "");

bool verifier(::llvm::raw_ostream &errs);

bool getVal() const;struct ArgumentIndex { enum Enum : uint32_t {
Val = 0,
};};


      };
    
      /// InsertElementOp
/// insert an element into a vector
/// 
///     Insert the given `value` into the given `vector` at the given `index` and
///     returns the result.
///   

      class InsertElementOp : public ::llvm::CallInst {
        static const ::llvm::StringLiteral s_name; //{"xd.ir.insertelement"};

      public:
        static bool classof(const ::llvm::CallInst* i) {
          return ::llvm_dialects::detail::isOverloadedOperation(i, s_name);
        }
        static bool classof(const ::llvm::Value* v) {
          return ::llvm::isa<::llvm::CallInst>(v) &&
                 classof(::llvm::cast<::llvm::CallInst>(v));
        }
    static InsertElementOp* create(::llvm_dialects::Builder& b, ::llvm::Value * vector, ::llvm::Value * value, ::llvm::Value * index, const llvm::Twine &instName = "");

bool verifier(::llvm::raw_ostream &errs);

::llvm::Value * getVector() const;
          void setVector(::llvm::Value * vector);
        ::llvm::Value * getValue() const;
          void setValue(::llvm::Value * value);
        ::llvm::Value * getIndex() const;
          void setIndex(::llvm::Value * index);
        struct ArgumentIndex { enum Enum : uint32_t {
Vector = 0,
Value = 1,
Index = 2,
};};
::llvm::Value * getResult();


      };
    
      /// InstNameConflictDoubleOp
/// demonstrate how name conflict will be avoided
/// 
///     Like InstNameConflictOp but this has a second parameter named like the
///     dialect compiler's first choice
///   

      class InstNameConflictDoubleOp : public ::llvm::CallInst {
        static const ::llvm::StringLiteral s_name; //{"xd.ir.inst.name.conflict.double"};

      public:
        static bool classof(const ::llvm::CallInst* i) {
          return ::llvm_dialects::detail::isSimpleOperation(i, s_name);
        }
        static bool classof(const ::llvm::Value* v) {
          return ::llvm::isa<::llvm::CallInst>(v) &&
                 classof(::llvm::cast<::llvm::CallInst>(v));
        }
    static InstNameConflictDoubleOp* create(::llvm_dialects::Builder& b, ::llvm::Value * instName, ::llvm::Value * instName_0, const llvm::Twine &instName_1 = "");

bool verifier(::llvm::raw_ostream &errs);

::llvm::Value * getInstName() const;
          void setInstName(::llvm::Value * instName);
        ::llvm::Value * getInstName_0() const;
          void setInstName_0(::llvm::Value * instName_0);
        struct ArgumentIndex { enum Enum : uint32_t {
InstName = 0,
InstName_0 = 1,
};};
::llvm::Value * getResult();


      };
    
      /// InstNameConflictOp
/// demonstrate how name conflict will be avoided
/// 
///     The builder accepts an additional argument to set the name of the created
///     value like IRBuilder methods. This op produces a conflict so the parameter
///     will be renamed.
///   

      class InstNameConflictOp : public ::llvm::CallInst {
        static const ::llvm::StringLiteral s_name; //{"xd.ir.inst.name.conflict"};

      public:
        static bool classof(const ::llvm::CallInst* i) {
          return ::llvm_dialects::detail::isSimpleOperation(i, s_name);
        }
        static bool classof(const ::llvm::Value* v) {
          return ::llvm::isa<::llvm::CallInst>(v) &&
                 classof(::llvm::cast<::llvm::CallInst>(v));
        }
    static InstNameConflictOp* create(::llvm_dialects::Builder& b, ::llvm::Value * instName, const llvm::Twine &instName_0 = "");

bool verifier(::llvm::raw_ostream &errs);

::llvm::Value * getInstName() const;
          void setInstName(::llvm::Value * instName);
        struct ArgumentIndex { enum Enum : uint32_t {
InstName = 0,
};};
::llvm::Value * getResult();


      };
    
      /// InstNameConflictVarargsOp
/// demonstrate how name conflict will be avoided
/// 
///     Like InstNameConflictOp but with varargs
///   

      class InstNameConflictVarargsOp : public ::llvm::CallInst {
        static const ::llvm::StringLiteral s_name; //{"xd.ir.inst.name.conflict.varargs"};

      public:
        static bool classof(const ::llvm::CallInst* i) {
          return ::llvm_dialects::detail::isSimpleOperation(i, s_name);
        }
        static bool classof(const ::llvm::Value* v) {
          return ::llvm::isa<::llvm::CallInst>(v) &&
                 classof(::llvm::cast<::llvm::CallInst>(v));
        }
    static InstNameConflictVarargsOp* create(::llvm_dialects::Builder& b, ::llvm::ArrayRef<::llvm::Value *> instName_0, const llvm::Twine &instName = "");

bool verifier(::llvm::raw_ostream &errs);

::llvm::iterator_range<::llvm::User::value_op_iterator> getInstName_0() ;
          /// Returns a new op with the same arguments and a new tail argument list.
          /// The object on which this is called will be replaced and erased.
          InstNameConflictVarargsOp *replaceInstName_0(::llvm::ArrayRef<Value *>);
        struct ArgumentIndex { enum Enum : uint32_t {
InstName_0Start = 0,
};};
::llvm::Value * getResult();


      };
    
      /// NoDescriptionOp
/// Some summary

      class NoDescriptionOp : public ::llvm::CallInst {
        static const ::llvm::StringLiteral s_name; //{"xd.ir.no.description.op"};

      public:
        static bool classof(const ::llvm::CallInst* i) {
          return ::llvm_dialects::detail::isSimpleOperation(i, s_name);
        }
        static bool classof(const ::llvm::Value* v) {
          return ::llvm::isa<::llvm::CallInst>(v) &&
                 classof(::llvm::cast<::llvm::CallInst>(v));
        }
    static NoDescriptionOp* create(::llvm_dialects::Builder& b, const llvm::Twine &instName = "");

bool verifier(::llvm::raw_ostream &errs);




      };
    
      /// NoSummaryOp
/// 
///     Some description
///   

      class NoSummaryOp : public ::llvm::CallInst {
        static const ::llvm::StringLiteral s_name; //{"xd.ir.no.summary.op"};

      public:
        static bool classof(const ::llvm::CallInst* i) {
          return ::llvm_dialects::detail::isSimpleOperation(i, s_name);
        }
        static bool classof(const ::llvm::Value* v) {
          return ::llvm::isa<::llvm::CallInst>(v) &&
                 classof(::llvm::cast<::llvm::CallInst>(v));
        }
    static NoSummaryOp* create(::llvm_dialects::Builder& b, const llvm::Twine &instName = "");

bool verifier(::llvm::raw_ostream &errs);




      };
    
      /// ReadOp
/// read a piece of data
/// 
///     Longer description of how this operation reads a piece of data.
///   

      class ReadOp : public ::llvm::CallInst {
        static const ::llvm::StringLiteral s_name; //{"xd.ir.read"};

      public:
        static bool classof(const ::llvm::CallInst* i) {
          return ::llvm_dialects::detail::isOverloadedOperation(i, s_name);
        }
        static bool classof(const ::llvm::Value* v) {
          return ::llvm::isa<::llvm::CallInst>(v) &&
                 classof(::llvm::cast<::llvm::CallInst>(v));
        }
    static ReadOp* create(::llvm_dialects::Builder& b, ::llvm::Type* dataType, const llvm::Twine &instName = "");

bool verifier(::llvm::raw_ostream &errs);


::llvm::Value * getData();


      };
    
      /// SetReadOp
/// read a piece of data
/// 
///     Longer description of how this operation reads a piece of data.
///   

      class SetReadOp : public ::llvm::CallInst {
        static const ::llvm::StringLiteral s_name; //{"xd.ir.set.read"};

      public:
        static bool classof(const ::llvm::CallInst* i) {
          return ::llvm_dialects::detail::isOverloadedOperation(i, s_name);
        }
        static bool classof(const ::llvm::Value* v) {
          return ::llvm::isa<::llvm::CallInst>(v) &&
                 classof(::llvm::cast<::llvm::CallInst>(v));
        }
    static SetReadOp* create(::llvm_dialects::Builder& b, ::llvm::Type* dataType, const llvm::Twine &instName = "");

bool verifier(::llvm::raw_ostream &errs);


::llvm::Value * getData();


      };
    
      /// SetWriteOp
/// write a data element
/// 
///     Longer description of how this operation writes pieces of data.
///   

      class SetWriteOp : public ::llvm::CallInst {
        static const ::llvm::StringLiteral s_name; //{"xd.ir.set.write"};

      public:
        static bool classof(const ::llvm::CallInst* i) {
          return ::llvm_dialects::detail::isSimpleOperation(i, s_name);
        }
        static bool classof(const ::llvm::Value* v) {
          return ::llvm::isa<::llvm::CallInst>(v) &&
                 classof(::llvm::cast<::llvm::CallInst>(v));
        }
    static SetWriteOp* create(::llvm_dialects::Builder& b, ::llvm::Value * data, const llvm::Twine &instName = "");

bool verifier(::llvm::raw_ostream &errs);

::llvm::Value * getData() const;
          void setData(::llvm::Value * data);
        struct ArgumentIndex { enum Enum : uint32_t {
Data = 0,
};};


      };
    
      /// SizeOfOp
/// size of a given type
/// 
///     Returns the store size of the given type in bytes.
///   

      class SizeOfOp : public ::llvm::CallInst {
        static const ::llvm::StringLiteral s_name; //{"xd.ir.sizeof"};

      public:
        static bool classof(const ::llvm::CallInst* i) {
          return ::llvm_dialects::detail::isSimpleOperation(i, s_name);
        }
        static bool classof(const ::llvm::Value* v) {
          return ::llvm::isa<::llvm::CallInst>(v) &&
                 classof(::llvm::cast<::llvm::CallInst>(v));
        }
    static SizeOfOp* create(::llvm_dialects::Builder& b, ::llvm::Type * sizeofType, const llvm::Twine &instName = "");

bool verifier(::llvm::raw_ostream &errs);

::llvm::Type * getSizeofType() const;
          void setSizeofType(::llvm::Type * sizeof_type);
        struct ArgumentIndex { enum Enum : uint32_t {
SizeofType = 0,
};};
::llvm::Value * getResult();


      };
    
      /// StreamAddOp
/// perform the add operation streaming from memory
/// 
///     Illustrate the use of the OpClass feature.
///   

      class StreamAddOp : public StreamReduceOp {
        static const ::llvm::StringLiteral s_name; //{"xd.ir.stream.add"};

      public:
        static bool classof(const ::llvm::CallInst* i) {
          return ::llvm_dialects::detail::isOverloadedOperation(i, s_name);
        }
        static bool classof(const ::llvm::Value* v) {
          return ::llvm::isa<::llvm::CallInst>(v) &&
                 classof(::llvm::cast<::llvm::CallInst>(v));
        }
    static StreamAddOp* create(::llvm_dialects::Builder& b, ::llvm::Value * ptr, ::llvm::Value * count, ::llvm::Value * initial, const llvm::Twine &instName = "");

bool verifier(::llvm::raw_ostream &errs);


::llvm::Value * getResult();


      };
    
      /// StreamMaxOp
/// perform the max operation streaming from memory
/// 
///     Illustrate the use of the OpClass feature.
///   

      class StreamMaxOp : public StreamReduceOp {
        static const ::llvm::StringLiteral s_name; //{"xd.ir.stream.max"};

      public:
        static bool classof(const ::llvm::CallInst* i) {
          return ::llvm_dialects::detail::isOverloadedOperation(i, s_name);
        }
        static bool classof(const ::llvm::Value* v) {
          return ::llvm::isa<::llvm::CallInst>(v) &&
                 classof(::llvm::cast<::llvm::CallInst>(v));
        }
    static StreamMaxOp* create(::llvm_dialects::Builder& b, ::llvm::Value * ptr, ::llvm::Value * count, ::llvm::Value * initial, const llvm::Twine &instName = "");

bool verifier(::llvm::raw_ostream &errs);


::llvm::Value * getResult();


      };
    
      /// StreamMinOp
/// perform the min operation streaming from memory
/// 
///     Illustrate the use of the OpClass feature.
///   

      class StreamMinOp : public StreamReduceOp {
        static const ::llvm::StringLiteral s_name; //{"xd.ir.stream.min"};

      public:
        static bool classof(const ::llvm::CallInst* i) {
          return ::llvm_dialects::detail::isOverloadedOperation(i, s_name);
        }
        static bool classof(const ::llvm::Value* v) {
          return ::llvm::isa<::llvm::CallInst>(v) &&
                 classof(::llvm::cast<::llvm::CallInst>(v));
        }
    static StreamMinOp* create(::llvm_dialects::Builder& b, ::llvm::Value * ptr, ::llvm::Value * count, ::llvm::Value * initial, const llvm::Twine &instName = "");

bool verifier(::llvm::raw_ostream &errs);


::llvm::Value * getResult();


      };
    
      /// StringAttrOp
/// demonstrate an argument that takes in a StringRef
/// 
///     The argument should not have a setter method
///   

      class StringAttrOp : public ::llvm::CallInst {
        static const ::llvm::StringLiteral s_name; //{"xd.ir.string.attr.op"};

      public:
        static bool classof(const ::llvm::CallInst* i) {
          return ::llvm_dialects::detail::isSimpleOperation(i, s_name);
        }
        static bool classof(const ::llvm::Value* v) {
          return ::llvm::isa<::llvm::CallInst>(v) &&
                 classof(::llvm::cast<::llvm::CallInst>(v));
        }
    static StringAttrOp* create(::llvm_dialects::Builder& b, ::llvm::StringRef val, const llvm::Twine &instName = "");

bool verifier(::llvm::raw_ostream &errs);

::llvm::StringRef getVal() const;struct ArgumentIndex { enum Enum : uint32_t {
Val = 0,
};};


      };
    
      /// WriteOp
/// write a piece of data
/// 
///     Longer description of how this operation writes a piece of data.
///   

      class WriteOp : public ::llvm::CallInst {
        static const ::llvm::StringLiteral s_name; //{"xd.ir.write"};

      public:
        static bool classof(const ::llvm::CallInst* i) {
          return ::llvm_dialects::detail::isSimpleOperation(i, s_name);
        }
        static bool classof(const ::llvm::Value* v) {
          return ::llvm::isa<::llvm::CallInst>(v) &&
                 classof(::llvm::cast<::llvm::CallInst>(v));
        }
    static WriteOp* create(::llvm_dialects::Builder& b, ::llvm::Value * data, const llvm::Twine &instName = "");

bool verifier(::llvm::raw_ostream &errs);

::llvm::Value * getData() const;
          void setData(::llvm::Value * data);
        struct ArgumentIndex { enum Enum : uint32_t {
Data = 0,
};};


      };
    
      /// WriteVarArgOp
/// write one or more data elements
/// 
///     Longer description of how this operation writes pieces of data.
///   

      class WriteVarArgOp : public ::llvm::CallInst {
        static const ::llvm::StringLiteral s_name; //{"xd.ir.write.vararg"};

      public:
        static bool classof(const ::llvm::CallInst* i) {
          return ::llvm_dialects::detail::isSimpleOperation(i, s_name);
        }
        static bool classof(const ::llvm::Value* v) {
          return ::llvm::isa<::llvm::CallInst>(v) &&
                 classof(::llvm::cast<::llvm::CallInst>(v));
        }
    static WriteVarArgOp* create(::llvm_dialects::Builder& b, ::llvm::Value * data, ::llvm::ArrayRef<::llvm::Value *> args, const llvm::Twine &instName = "");

bool verifier(::llvm::raw_ostream &errs);

::llvm::Value * getData() const;
          void setData(::llvm::Value * data);
        ::llvm::iterator_range<::llvm::User::value_op_iterator> getArgs() ;
          /// Returns a new op with the same arguments and a new tail argument list.
          /// The object on which this is called will be replaced and erased.
          WriteVarArgOp *replaceArgs(::llvm::ArrayRef<Value *>);
        struct ArgumentIndex { enum Enum : uint32_t {
Data = 0,
ArgsStart = 1,
};};


      };
    } // namespace xd::cpp

#endif // GET_DIALECT_DECLS
