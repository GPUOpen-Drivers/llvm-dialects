// DO NOT EDIT! This file is automatically generated by llvm-dialects-tblgen.


#ifdef GET_INCLUDES
#undef GET_INCLUDES
#include "llvm-dialects/Dialect/Builder.h"
#include "llvm-dialects/Dialect/OpDescription.h"
#include "llvm-dialects/Dialect/Utils.h"
#include "llvm/IR/InstrTypes.h"

#include "llvm/Support/ModRef.h"

#endif // GET_INCLUDES

#ifdef GET_DIALECT_DEFS
#undef GET_DIALECT_DEFS
namespace xd {

    void ExampleDialect::anchor() {}

    ::llvm_dialects::Dialect::Key& ExampleDialect::getKey() {
      static Key s_key;
      return s_key;
    }

    ::llvm_dialects::Dialect* ExampleDialect::make(::llvm::LLVMContext& context) {
      return new ExampleDialect(context);
    }

    ExampleDialect::ExampleDialect(::llvm::LLVMContext& context) : DialectImpl(context) {
  {
  ::llvm::AttrBuilder attrBuilder{context};
attrBuilder.addAttribute(::llvm::Attribute::NoUnwind);
attrBuilder.addAttribute(::llvm::Attribute::WillReturn);
attrBuilder.addMemoryAttr(::llvm::MemoryEffects(::llvm::MemoryEffects::Location::InaccessibleMem, ::llvm::ModRefInfo::Mod));
m_attributeLists[0] = ::llvm::AttributeList::get(context, ::llvm::AttributeList::FunctionIndex, attrBuilder);
}
{
  ::llvm::AttrBuilder attrBuilder{context};
attrBuilder.addAttribute(::llvm::Attribute::NoUnwind);
attrBuilder.addAttribute(::llvm::Attribute::WillReturn);
attrBuilder.addMemoryAttr(::llvm::MemoryEffects::none());
m_attributeLists[1] = ::llvm::AttributeList::get(context, ::llvm::AttributeList::FunctionIndex, attrBuilder);
}
{
  ::llvm::AttrBuilder attrBuilder{context};
attrBuilder.addAttribute(::llvm::Attribute::NoUnwind);
attrBuilder.addMemoryAttr(::llvm::MemoryEffects(::llvm::MemoryEffects::Location::InaccessibleMem, ::llvm::ModRefInfo::ModRef));
m_attributeLists[2] = ::llvm::AttributeList::get(context, ::llvm::AttributeList::FunctionIndex, attrBuilder);
}
}


      const ::llvm::StringLiteral Add32Op::s_name{"xd.add32"};

    ::llvm::Value* Add32Op::create(llvm_dialects::Builder& b, ::llvm::Value * lhs, ::llvm::Value * rhs, uint32_t extra) {
      ::llvm::LLVMContext& context = b.getContext();
      ::llvm::Module& mod = *b.GetInsertBlock()->getModule();
    
    assert(lhs->getType() == ::llvm::Type::getInt32Ty(context));
assert(rhs->getType() == ::llvm::Type::getInt32Ty(context));

        const ::llvm::AttributeList attrs
            = ExampleDialect::get(context).getAttributeList(1);
      llvm::Type* I32 = ::llvm::Type::getInt32Ty(context);
llvm::Type* I32_0 = ::llvm::Type::getInt32Ty(context);

auto fnType = ::llvm::FunctionType::get(I32_0, {
lhs->getType(),
rhs->getType(),
I32,
}, false);

auto fn = mod.getOrInsertFunction(s_name, fnType, attrs);

::llvm::Value* const args[] = {
lhs,
rhs,
 ::llvm::ConstantInt::get(I32, extra) ,
};

return b.CreateCall(fn, args);
}


        ::llvm::Value * Add32Op::getLhs() {
          return getArgOperand(0);
        }
      
        ::llvm::Value * Add32Op::getRhs() {
          return getArgOperand(1);
        }
      
        uint32_t Add32Op::getExtra() {
          return  ::llvm::cast<::llvm::ConstantInt>(getArgOperand(2))->getZExtValue() ;
        }
      
::llvm::Value* Add32Op::getResult() {return this;}



      const ::llvm::StringLiteral CombineOp::s_name{"xd.combine"};

    ::llvm::Value* CombineOp::create(llvm_dialects::Builder& b, ::llvm::Type* resultType, ::llvm::Value * lhs, ::llvm::Value * rhs) {
      ::llvm::LLVMContext& context = b.getContext();
      ::llvm::Module& mod = *b.GetInsertBlock()->getModule();
    
    assert(true);
assert(true);

        const ::llvm::AttributeList attrs
            = ExampleDialect::get(context).getAttributeList(1);
      assert((::llvm_dialects::areTypesEqual({lhs->getType(), rhs->getType()})));
assert((::llvm_dialects::areTypesEqual({resultType, lhs->getType()})));

std::string mangledName = ::llvm_dialects::getMangledName(s_name, {
resultType,
});
auto fnType = ::llvm::FunctionType::get(resultType, true);

auto fn = mod.getOrInsertFunction(mangledName, fnType, attrs);

::llvm::Value* const args[] = {
lhs,
rhs,
};

return b.CreateCall(fn, args);
}


        ::llvm::Value * CombineOp::getLhs() {
          return getArgOperand(0);
        }
      
        ::llvm::Value * CombineOp::getRhs() {
          return getArgOperand(1);
        }
      
::llvm::Value* CombineOp::getResult() {return this;}



      const ::llvm::StringLiteral ReadOp::s_name{"xd.read"};

    ::llvm::Value* ReadOp::create(llvm_dialects::Builder& b, ::llvm::Type* dataType) {
      ::llvm::LLVMContext& context = b.getContext();
      ::llvm::Module& mod = *b.GetInsertBlock()->getModule();
    
    
        const ::llvm::AttributeList attrs
            = ExampleDialect::get(context).getAttributeList(2);
      
std::string mangledName = ::llvm_dialects::getMangledName(s_name, {
dataType,
});
auto fnType = ::llvm::FunctionType::get(dataType, {
}, false);

auto fn = mod.getOrInsertFunction(mangledName, fnType, attrs);

return b.CreateCall(fn);
}


::llvm::Value* ReadOp::getData() {return this;}



      const ::llvm::StringLiteral WriteOp::s_name{"xd.write"};

    ::llvm::Value* WriteOp::create(llvm_dialects::Builder& b, ::llvm::Value * data) {
      ::llvm::LLVMContext& context = b.getContext();
      ::llvm::Module& mod = *b.GetInsertBlock()->getModule();
    
    assert(true);

        const ::llvm::AttributeList attrs
            = ExampleDialect::get(context).getAttributeList(0);
      llvm::Type* VoidTy = ::llvm::Type::getVoidTy(context);

auto fnType = ::llvm::FunctionType::get(VoidTy, true);

auto fn = mod.getOrInsertFunction(s_name, fnType, attrs);

::llvm::Value* const args[] = {
data,
};

return b.CreateCall(fn, args);
}


        ::llvm::Value * WriteOp::getData() {
          return getArgOperand(0);
        }
      


} // namespace xd

      template <>
      const ::llvm_dialects::OpDescription &
      ::llvm_dialects::OpDescription::get<xd::Add32Op>() {
        static const ::llvm_dialects::OpDescription desc{false, "xd.add32"};
        return desc;
      }

    
      template <>
      const ::llvm_dialects::OpDescription &
      ::llvm_dialects::OpDescription::get<xd::CombineOp>() {
        static const ::llvm_dialects::OpDescription desc{true, "xd.combine"};
        return desc;
      }

    
      template <>
      const ::llvm_dialects::OpDescription &
      ::llvm_dialects::OpDescription::get<xd::ReadOp>() {
        static const ::llvm_dialects::OpDescription desc{true, "xd.read"};
        return desc;
      }

    
      template <>
      const ::llvm_dialects::OpDescription &
      ::llvm_dialects::OpDescription::get<xd::WriteOp>() {
        static const ::llvm_dialects::OpDescription desc{false, "xd.write"};
        return desc;
      }

    
#endif // GET_DIALECT_DEFS
