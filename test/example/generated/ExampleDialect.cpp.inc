// DO NOT EDIT! This file is automatically generated by llvm-dialects-tblgen.


#ifdef GET_INCLUDES
#undef GET_INCLUDES
#include "llvm-dialects/Dialect/Builder.h"
#include "llvm-dialects/Dialect/OpDescription.h"
#include "llvm-dialects/Dialect/Utils.h"
#include "llvm-dialects/Dialect/Verifier.h"
#include "llvm-dialects/Dialect/Visitor.h"
#include "llvm/ADT/ArrayRef.h"
#include "llvm/ADT/SmallString.h"
#include "llvm/ADT/SmallVector.h"
#include "llvm/ADT/StringExtras.h"
#include "llvm/IR/InstrTypes.h"

#include "llvm/Support/ModRef.h"

#include "llvm/Support/raw_ostream.h"
#endif // GET_INCLUDES

#ifdef GET_DIALECT_DEFS
#undef GET_DIALECT_DEFS
namespace xd {

    void ExampleDialect::anchor() {}

    ::llvm_dialects::Dialect::Key& ExampleDialect::getKey() {
      static Key s_key;
      return s_key;
    }

    ::llvm_dialects::Dialect* ExampleDialect::make(::llvm::LLVMContext& context) {
      
      auto verifierBuild = [](::llvm_dialects::VisitorBuilder<::llvm_dialects::VerifierState> &builder) {
    
        builder.add<Add32Op>([](::llvm_dialects::VerifierState &state, Add32Op &op) {
          if (!op.verifier(state.out()))
            state.setError();
        });
      
        builder.add<CombineOp>([](::llvm_dialects::VerifierState &state, CombineOp &op) {
          if (!op.verifier(state.out()))
            state.setError();
        });
      
        builder.add<ExtractElementOp>([](::llvm_dialects::VerifierState &state, ExtractElementOp &op) {
          if (!op.verifier(state.out()))
            state.setError();
        });
      
        builder.add<FromFixedVectorOp>([](::llvm_dialects::VerifierState &state, FromFixedVectorOp &op) {
          if (!op.verifier(state.out()))
            state.setError();
        });
      
        builder.add<HandleGetOp>([](::llvm_dialects::VerifierState &state, HandleGetOp &op) {
          if (!op.verifier(state.out()))
            state.setError();
        });
      
        builder.add<IExtOp>([](::llvm_dialects::VerifierState &state, IExtOp &op) {
          if (!op.verifier(state.out()))
            state.setError();
        });
      
        builder.add<ITruncOp>([](::llvm_dialects::VerifierState &state, ITruncOp &op) {
          if (!op.verifier(state.out()))
            state.setError();
        });
      
        builder.add<InsertElementOp>([](::llvm_dialects::VerifierState &state, InsertElementOp &op) {
          if (!op.verifier(state.out()))
            state.setError();
        });
      
        builder.add<ReadOp>([](::llvm_dialects::VerifierState &state, ReadOp &op) {
          if (!op.verifier(state.out()))
            state.setError();
        });
      
        builder.add<SetReadOp>([](::llvm_dialects::VerifierState &state, SetReadOp &op) {
          if (!op.verifier(state.out()))
            state.setError();
        });
      
        builder.add<SetWriteOp>([](::llvm_dialects::VerifierState &state, SetWriteOp &op) {
          if (!op.verifier(state.out()))
            state.setError();
        });
      
        builder.add<SizeOfOp>([](::llvm_dialects::VerifierState &state, SizeOfOp &op) {
          if (!op.verifier(state.out()))
            state.setError();
        });
      
        builder.add<StreamAddOp>([](::llvm_dialects::VerifierState &state, StreamAddOp &op) {
          if (!op.verifier(state.out()))
            state.setError();
        });
      
        builder.add<StreamMaxOp>([](::llvm_dialects::VerifierState &state, StreamMaxOp &op) {
          if (!op.verifier(state.out()))
            state.setError();
        });
      
        builder.add<StreamMinOp>([](::llvm_dialects::VerifierState &state, StreamMinOp &op) {
          if (!op.verifier(state.out()))
            state.setError();
        });
      
        builder.add<WriteOp>([](::llvm_dialects::VerifierState &state, WriteOp &op) {
          if (!op.verifier(state.out()))
            state.setError();
        });
      
        builder.add<WriteVarArgOp>([](::llvm_dialects::VerifierState &state, WriteVarArgOp &op) {
          if (!op.verifier(state.out()))
            state.setError();
        });
      
      };
      static const ::llvm_dialects::VerifierExtension verifierExtension = {
        verifierBuild,
      };
      static ::llvm_dialects::DialectExtensionRegistration<::llvm_dialects::VerifierExtension, ExampleDialect>
          verifierExtensionRegistration(::llvm_dialects::getVerifierExtensionPoint(), &verifierExtension);
    
      return new ExampleDialect(context);
    }

    ExampleDialect::ExampleDialect(::llvm::LLVMContext& context) : DialectImpl(context) {
  {
  ::llvm::AttrBuilder attrBuilder{context};
attrBuilder.addAttribute(::llvm::Attribute::NoUnwind);
attrBuilder.addAttribute(::llvm::Attribute::WillReturn);
attrBuilder.addMemoryAttr(::llvm::MemoryEffects(::llvm::MemoryEffects::Location::InaccessibleMem, ::llvm::ModRefInfo::Mod));
m_attributeLists[0] = ::llvm::AttributeList::get(context, ::llvm::AttributeList::FunctionIndex, attrBuilder);
}
{
  ::llvm::AttrBuilder attrBuilder{context};
attrBuilder.addAttribute(::llvm::Attribute::NoUnwind);
attrBuilder.addAttribute(::llvm::Attribute::WillReturn);
attrBuilder.addMemoryAttr(::llvm::MemoryEffects::none());
m_attributeLists[1] = ::llvm::AttributeList::get(context, ::llvm::AttributeList::FunctionIndex, attrBuilder);
}
{
  ::llvm::AttrBuilder attrBuilder{context};
attrBuilder.addAttribute(::llvm::Attribute::NoUnwind);
attrBuilder.addAttribute(::llvm::Attribute::WillReturn);
attrBuilder.addMemoryAttr(::llvm::MemoryEffects(::llvm::ModRefInfo::Ref));
m_attributeLists[2] = ::llvm::AttributeList::get(context, ::llvm::AttributeList::FunctionIndex, attrBuilder);
}
{
  ::llvm::AttrBuilder attrBuilder{context};
attrBuilder.addAttribute(::llvm::Attribute::NoUnwind);
attrBuilder.addMemoryAttr(::llvm::MemoryEffects(::llvm::MemoryEffects::Location::InaccessibleMem, ::llvm::ModRefInfo::ModRef));
m_attributeLists[3] = ::llvm::AttributeList::get(context, ::llvm::AttributeList::FunctionIndex, attrBuilder);
}
}

XdHandleType* XdHandleType::get(::llvm::LLVMContext & ctx) {
::std::array<::llvm::Type *, 0> types = {

    };
    ::std::array<unsigned, 0> ints = {
  
      };

      auto *type = ::llvm::cast<XdHandleType>(::llvm::TargetExtType::get(ctx, s_name, types, ints));
      assert(::llvm_dialects::runTypeVerifier([type](llvm::raw_ostream &errs) {
        return type->verifier(errs);
      }, type));
      return type;
    }
  
    bool XdHandleType::verifier(::llvm::raw_ostream &errs) const {
      ::llvm::LLVMContext &ctx = getContext();
      (void)ctx;

      using ::llvm_dialects::printable;

      if (getNumTypeParameters() != 0) {
        errs << "  wrong number of type parameters\n";
        errs << "    expected: 0\n";
        errs << "      actual: " << getNumTypeParameters() << '\n';
        return false;
      }

      if (getNumIntParameters() != 0) {
        errs << "  wrong number of int parameters\n";
        errs << "    expected: 0\n";
        errs << "      actual: " << getNumIntParameters() << '\n';
        return false;
      }
  return true;
}


      VectorKind XdVectorType::getKind() const {
        return static_cast<VectorKind>(int_params()[0]);
      }

    
      ::llvm::Type * XdVectorType::getElementType() const {
        return type_params()[0];
      }

    
      uint32_t XdVectorType::getNumElements() const {
        return int_params()[1];
      }

    XdVectorType* XdVectorType::get(VectorKind kind, ::llvm::Type * elementType, uint32_t numElements) {
::llvm::LLVMContext &ctx = elementType->getContext();
static_assert(sizeof(kind) <= sizeof(unsigned));

::std::array<::llvm::Type *, 1> types = {
elementType,

    };
    ::std::array<unsigned, 2> ints = {
  static_cast<unsigned>(kind),
numElements,

      };

      auto *type = ::llvm::cast<XdVectorType>(::llvm::TargetExtType::get(ctx, s_name, types, ints));
      assert(::llvm_dialects::runTypeVerifier([type](llvm::raw_ostream &errs) {
        return type->verifier(errs);
      }, type));
      return type;
    }
  
    bool XdVectorType::verifier(::llvm::raw_ostream &errs) const {
      ::llvm::LLVMContext &ctx = getContext();
      (void)ctx;

      using ::llvm_dialects::printable;

      if (getNumTypeParameters() != 1) {
        errs << "  wrong number of type parameters\n";
        errs << "    expected: 1\n";
        errs << "      actual: " << getNumTypeParameters() << '\n';
        return false;
      }

      if (getNumIntParameters() != 2) {
        errs << "  wrong number of int parameters\n";
        errs << "    expected: 2\n";
        errs << "      actual: " << getNumIntParameters() << '\n';
        return false;
      }
  auto kind = getKind();
(void)kind;
auto elementType = getElementType();
(void)elementType;
auto numElements = getNumElements();
(void)numElements;
return true;
}


      bool StreamReduceOp::classof(const ::llvm::CallInst* i) {
    
        if (StreamAddOp::classof(i)) return true;
      
        if (StreamMaxOp::classof(i)) return true;
      
        if (StreamMinOp::classof(i)) return true;
      
        return false;
      }

    
      ::llvm::Value * StreamReduceOp::getPtr() {
        return getArgOperand(0);
      }

      void StreamReduceOp::setPtr(::llvm::Value * ptr) {
        setArgOperand(0, ptr);
      }
      ::llvm::Value * StreamReduceOp::getCount() {
        return getArgOperand(1);
      }

      void StreamReduceOp::setCount(::llvm::Value * count) {
        setArgOperand(1, count);
      }
      ::llvm::Value * StreamReduceOp::getInitial() {
        return getArgOperand(2);
      }

      void StreamReduceOp::setInitial(::llvm::Value * initial) {
        setArgOperand(2, initial);
      }

      const ::llvm::StringLiteral Add32Op::s_name{"xd.add32"};

    Add32Op* Add32Op::create(llvm_dialects::Builder& b, ::llvm::Value * lhs, ::llvm::Value * rhs, uint32_t extra) {
    ::llvm::LLVMContext& context = b.getContext();
    (void)context;
    ::llvm::Module& module = *b.GetInsertBlock()->getModule();
  
  
      const ::llvm::AttributeList attrs
          = ExampleDialect::get(context).getAttributeList(1);
    auto fnType = ::llvm::FunctionType::get(::llvm::IntegerType::get(context, 32), {
lhs->getType(),
rhs->getType(),
::llvm::IntegerType::get(context, 32),
}, false);

    auto fn = module.getOrInsertFunction(s_name, fnType, attrs);
    ::llvm::SmallString<32> newName;
    for (unsigned i = 0; !::llvm::isa<::llvm::Function>(fn.getCallee()) ||
                         ::llvm::cast<::llvm::Function>(fn.getCallee())->getFunctionType() != fn.getFunctionType(); i++) {
      // If a function with the same name but a different types already exists,
      // we get a bitcast of a function or a function with the wrong type.
      // Try new names until we get one with the correct type.
      newName = "";
      ::llvm::raw_svector_ostream newNameStream(newName);
      newNameStream << s_name << "_" << i;
      fn = module.getOrInsertFunction(newNameStream.str(), fnType, attrs);
    }
    assert(::llvm::isa<::llvm::Function>(fn.getCallee()));
    assert(fn.getFunctionType() == fnType);
    assert(::llvm::cast<::llvm::Function>(fn.getCallee())->getFunctionType() == fn.getFunctionType());

  
::llvm::SmallVector<::llvm::Value*, 3> args = {
lhs,
rhs,
 ::llvm::ConstantInt::get(::llvm::IntegerType::get(context, 32), extra) 
      };
      
      return ::llvm::cast<Add32Op>(b.CreateCall(fn, args));
    }


    bool Add32Op::verifier(::llvm::raw_ostream &errs) {
      ::llvm::LLVMContext &context = getModule()->getContext();
      (void)context;

      using ::llvm_dialects::printable;

      if (arg_size() != 3) {
        errs << "  wrong number of arguments: " << arg_size()
               << ", expected 3\n";
        return false;
      }
  
        if (getArgOperand(2)->getType() != ::llvm::IntegerType::get(context, 32)) {
          errs << "  argument 2 (extra) has type: "
                 << *getArgOperand(2)->getType() << '\n';
          errs << "  expected: " << *::llvm::IntegerType::get(context, 32) << '\n';
          return false;
        }
      ::llvm::Type * const lhsType = getLhs()->getType();
(void)lhsType;
::llvm::Type * const rhsType = getRhs()->getType();
(void)rhsType;
uint32_t const extra = getExtra();
(void)extra;
::llvm::Type * const resultType = getResult()->getType();
(void)resultType;

        if (::llvm::IntegerType::get(context, 32) != lhsType) {
          errs << "  unexpected value of $lhs:\n";
          errs << "    expected:  " << printable(::llvm::IntegerType::get(context, 32)) << '\n';
          errs << "    actual:    " << printable(lhsType) << '\n';
        
          return false;
        }
      
        if (::llvm::IntegerType::get(context, 32) != rhsType) {
          errs << "  unexpected value of $rhs:\n";
          errs << "    expected:  " << printable(::llvm::IntegerType::get(context, 32)) << '\n';
          errs << "    actual:    " << printable(rhsType) << '\n';
        
          return false;
        }
      
        if (::llvm::IntegerType::get(context, 32) != resultType) {
          errs << "  unexpected value of $result:\n";
          errs << "    expected:  " << printable(::llvm::IntegerType::get(context, 32)) << '\n';
          errs << "    actual:    " << printable(resultType) << '\n';
        
          return false;
        }
        return true;
}


      ::llvm::Value * Add32Op::getLhs() {
        return getArgOperand(0);
      }

      void Add32Op::setLhs(::llvm::Value * lhs) {
        setArgOperand(0, lhs);
      }
      ::llvm::Value * Add32Op::getRhs() {
        return getArgOperand(1);
      }

      void Add32Op::setRhs(::llvm::Value * rhs) {
        setArgOperand(1, rhs);
      }
      uint32_t Add32Op::getExtra() {
        return  ::llvm::cast<::llvm::ConstantInt>(getArgOperand(2))->getZExtValue() ;
      }

      void Add32Op::setExtra(uint32_t extra) {
        setArgOperand(2,  ::llvm::ConstantInt::get(::llvm::IntegerType::get(getContext(), 32), extra) );
      }
::llvm::Value *Add32Op::getResult() {return this;}



      const ::llvm::StringLiteral CombineOp::s_name{"xd.combine"};

    CombineOp* CombineOp::create(llvm_dialects::Builder& b, ::llvm::Value * lhs, ::llvm::Value * rhs) {
    ::llvm::LLVMContext& context = b.getContext();
    (void)context;
    ::llvm::Module& module = *b.GetInsertBlock()->getModule();
  
  
      const ::llvm::AttributeList attrs
          = ExampleDialect::get(context).getAttributeList(1);
    
      std::string mangledName =
          ::llvm_dialects::getMangledName(s_name, {lhs->getType()});
    auto fnType = ::llvm::FunctionType::get(lhs->getType(), true);

    auto fn = module.getOrInsertFunction(mangledName, fnType, attrs);
    ::llvm::SmallString<32> newName;
    for (unsigned i = 0; !::llvm::isa<::llvm::Function>(fn.getCallee()) ||
                         ::llvm::cast<::llvm::Function>(fn.getCallee())->getFunctionType() != fn.getFunctionType(); i++) {
      // If a function with the same name but a different types already exists,
      // we get a bitcast of a function or a function with the wrong type.
      // Try new names until we get one with the correct type.
      newName = "";
      ::llvm::raw_svector_ostream newNameStream(newName);
      newNameStream << mangledName << "_" << i;
      fn = module.getOrInsertFunction(newNameStream.str(), fnType, attrs);
    }
    assert(::llvm::isa<::llvm::Function>(fn.getCallee()));
    assert(fn.getFunctionType() == fnType);
    assert(::llvm::cast<::llvm::Function>(fn.getCallee())->getFunctionType() == fn.getFunctionType());

  ::llvm::SmallVector<::llvm::Value*, 2> args = {
lhs,
rhs
      };
      
      return ::llvm::cast<CombineOp>(b.CreateCall(fn, args));
    }


    bool CombineOp::verifier(::llvm::raw_ostream &errs) {
      ::llvm::LLVMContext &context = getModule()->getContext();
      (void)context;

      using ::llvm_dialects::printable;

      if (arg_size() != 2) {
        errs << "  wrong number of arguments: " << arg_size()
               << ", expected 2\n";
        return false;
      }
  ::llvm::Type * const lhsType = getLhs()->getType();
(void)lhsType;
::llvm::Type * const rhsType = getRhs()->getType();
(void)rhsType;
::llvm::Type * const resultType = getResult()->getType();
(void)resultType;

        if (resultType != lhsType) {
          errs << "  unexpected value of $lhs:\n";
          errs << "    expected:  " << printable(resultType) << '\n';
          errs << "    actual:    " << printable(lhsType) << '\n';
        
          return false;
        }
      
        if (resultType != rhsType) {
          errs << "  unexpected value of $rhs:\n";
          errs << "    expected:  " << printable(resultType) << '\n';
          errs << "    actual:    " << printable(rhsType) << '\n';
        
          return false;
        }
        return true;
}


      ::llvm::Value * CombineOp::getLhs() {
        return getArgOperand(0);
      }

      void CombineOp::setLhs(::llvm::Value * lhs) {
        setArgOperand(0, lhs);
      }
      ::llvm::Value * CombineOp::getRhs() {
        return getArgOperand(1);
      }

      void CombineOp::setRhs(::llvm::Value * rhs) {
        setArgOperand(1, rhs);
      }
::llvm::Value *CombineOp::getResult() {return this;}



      const ::llvm::StringLiteral ExtractElementOp::s_name{"xd.extractelement"};

    ExtractElementOp* ExtractElementOp::create(llvm_dialects::Builder& b, ::llvm::Value * vector, ::llvm::Value * index) {
    ::llvm::LLVMContext& context = b.getContext();
    (void)context;
    ::llvm::Module& module = *b.GetInsertBlock()->getModule();
  
  
      const ::llvm::AttributeList attrs
          = ExampleDialect::get(context).getAttributeList(1);
    
      std::string mangledName =
          ::llvm_dialects::getMangledName(s_name, {::llvm::cast<XdVectorType>(vector->getType())->getElementType()});
    auto fnType = ::llvm::FunctionType::get(::llvm::cast<XdVectorType>(vector->getType())->getElementType(), true);

    auto fn = module.getOrInsertFunction(mangledName, fnType, attrs);
    ::llvm::SmallString<32> newName;
    for (unsigned i = 0; !::llvm::isa<::llvm::Function>(fn.getCallee()) ||
                         ::llvm::cast<::llvm::Function>(fn.getCallee())->getFunctionType() != fn.getFunctionType(); i++) {
      // If a function with the same name but a different types already exists,
      // we get a bitcast of a function or a function with the wrong type.
      // Try new names until we get one with the correct type.
      newName = "";
      ::llvm::raw_svector_ostream newNameStream(newName);
      newNameStream << mangledName << "_" << i;
      fn = module.getOrInsertFunction(newNameStream.str(), fnType, attrs);
    }
    assert(::llvm::isa<::llvm::Function>(fn.getCallee()));
    assert(fn.getFunctionType() == fnType);
    assert(::llvm::cast<::llvm::Function>(fn.getCallee())->getFunctionType() == fn.getFunctionType());

  ::llvm::SmallVector<::llvm::Value*, 2> args = {
vector,
index
      };
      
      return ::llvm::cast<ExtractElementOp>(b.CreateCall(fn, args));
    }


    bool ExtractElementOp::verifier(::llvm::raw_ostream &errs) {
      ::llvm::LLVMContext &context = getModule()->getContext();
      (void)context;

      using ::llvm_dialects::printable;

      if (arg_size() != 2) {
        errs << "  wrong number of arguments: " << arg_size()
               << ", expected 2\n";
        return false;
      }
  ::llvm::Type * const vectorType = getVector()->getType();
(void)vectorType;
::llvm::Type * const indexType = getIndex()->getType();
(void)indexType;
::llvm::Type * const resultType = getResult()->getType();
(void)resultType;

        if (::llvm::IntegerType::get(context, 32) != indexType) {
          errs << "  unexpected value of $index:\n";
          errs << "    expected:  " << printable(::llvm::IntegerType::get(context, 32)) << '\n';
          errs << "    actual:    " << printable(indexType) << '\n';
        
          return false;
        }
      
        if (!(::llvm::isa<XdVectorType>(vectorType))) {
          errs << "  failed check for (XdVectorType any, ?:$result, any):$vector\n";
          
      errs << "  with $vector = " << printable(vectorType) << '\n';
    
        
          return false;
        }
      
        if (::llvm::cast<XdVectorType>(vectorType)->getElementType() != resultType) {
          errs << "  unexpected value of $result:\n";
          errs << "    expected:  " << printable(::llvm::cast<XdVectorType>(vectorType)->getElementType()) << '\n';
          errs << "    actual:    " << printable(resultType) << '\n';
        
          return false;
        }
        return true;
}


      ::llvm::Value * ExtractElementOp::getVector() {
        return getArgOperand(0);
      }

      void ExtractElementOp::setVector(::llvm::Value * vector) {
        setArgOperand(0, vector);
      }
      ::llvm::Value * ExtractElementOp::getIndex() {
        return getArgOperand(1);
      }

      void ExtractElementOp::setIndex(::llvm::Value * index) {
        setArgOperand(1, index);
      }
::llvm::Value *ExtractElementOp::getResult() {return this;}



      const ::llvm::StringLiteral FromFixedVectorOp::s_name{"xd.fromfixedvector"};

    FromFixedVectorOp* FromFixedVectorOp::create(llvm_dialects::Builder& b, ::llvm::Type* resultType, ::llvm::Value * source) {
    ::llvm::LLVMContext& context = b.getContext();
    (void)context;
    ::llvm::Module& module = *b.GetInsertBlock()->getModule();
  
  
      const ::llvm::AttributeList attrs
          = ExampleDialect::get(context).getAttributeList(1);
    
      std::string mangledName =
          ::llvm_dialects::getMangledName(s_name, {resultType});
    auto fnType = ::llvm::FunctionType::get(resultType, true);

    auto fn = module.getOrInsertFunction(mangledName, fnType, attrs);
    ::llvm::SmallString<32> newName;
    for (unsigned i = 0; !::llvm::isa<::llvm::Function>(fn.getCallee()) ||
                         ::llvm::cast<::llvm::Function>(fn.getCallee())->getFunctionType() != fn.getFunctionType(); i++) {
      // If a function with the same name but a different types already exists,
      // we get a bitcast of a function or a function with the wrong type.
      // Try new names until we get one with the correct type.
      newName = "";
      ::llvm::raw_svector_ostream newNameStream(newName);
      newNameStream << mangledName << "_" << i;
      fn = module.getOrInsertFunction(newNameStream.str(), fnType, attrs);
    }
    assert(::llvm::isa<::llvm::Function>(fn.getCallee()));
    assert(fn.getFunctionType() == fnType);
    assert(::llvm::cast<::llvm::Function>(fn.getCallee())->getFunctionType() == fn.getFunctionType());

  ::llvm::SmallVector<::llvm::Value*, 1> args = {
source
      };
      
      return ::llvm::cast<FromFixedVectorOp>(b.CreateCall(fn, args));
    }


    bool FromFixedVectorOp::verifier(::llvm::raw_ostream &errs) {
      ::llvm::LLVMContext &context = getModule()->getContext();
      (void)context;

      using ::llvm_dialects::printable;

      if (arg_size() != 1) {
        errs << "  wrong number of arguments: " << arg_size()
               << ", expected 1\n";
        return false;
      }
  ::llvm::Type * const sourceType = getSource()->getType();
(void)sourceType;
::llvm::Type * const resultType = getResult()->getType();
(void)resultType;

        if (!(::llvm::isa<::llvm::FixedVectorType>(sourceType))) {
          errs << "  failed check for (FixedVectorType ?:$scalar_type, ?:$num_elements):$source\n";
          
      errs << "  with $source = " << printable(sourceType) << '\n';
    
        
          return false;
        }
      
        if (!(::llvm::isa<XdVectorType>(resultType))) {
          errs << "  failed check for (XdVectorType ?:$kind, ?:$scalar_type, ?:$num_elements):$result\n";
          
      errs << "  with $result = " << printable(resultType) << '\n';
    
        
          return false;
        }
      
        if (::llvm::cast<XdVectorType>(resultType)->getElementType() != ::llvm::cast<::llvm::FixedVectorType>(sourceType)->getElementType()) {
          errs << "  unexpected value of $scalar_type:\n";
          errs << "    expected:  " << printable(::llvm::cast<XdVectorType>(resultType)->getElementType()) << '\n';
          errs << "    actual:    " << printable(::llvm::cast<::llvm::FixedVectorType>(sourceType)->getElementType()) << '\n';
        
          return false;
        }
      
        if (::llvm::cast<XdVectorType>(resultType)->getNumElements() != ::llvm::cast<::llvm::FixedVectorType>(sourceType)->getNumElements()) {
          errs << "  unexpected value of $num_elements:\n";
          errs << "    expected:  " << printable(::llvm::cast<XdVectorType>(resultType)->getNumElements()) << '\n';
          errs << "    actual:    " << printable(::llvm::cast<::llvm::FixedVectorType>(sourceType)->getNumElements()) << '\n';
        
          return false;
        }
      if (![&]() {

      {
        if (true
    
      && !([&]() {
    
        if (xd::VectorKind::LittleEndian != ::llvm::cast<XdVectorType>(resultType)->getKind()) {
          return false;
        }
      return true;
}())

      && !([&]() {
    
        if (xd::VectorKind::BigEndian != ::llvm::cast<XdVectorType>(resultType)->getKind()) {
          return false;
        }
      return true;
}())
) {

        errs << "  eq:$rhs (" << printable(::llvm::cast<XdVectorType>(resultType)->getKind())
               << ") does not match any available option\n";
      
        errs << "  failed option 0 (VectorKindLittleEndian):\n";
        ([&]() {
      
        if (xd::VectorKind::LittleEndian != ::llvm::cast<XdVectorType>(resultType)->getKind()) {
          errs << "  inconsistent value of eq:$rhs found\n";
          errs << "  while checking VectorKindLittleEndian:\n";
          errs << "    here:       " << printable(xd::VectorKind::LittleEndian) << '\n';
          errs << "    previously: " << printable(::llvm::cast<XdVectorType>(resultType)->getKind()) << '\n';
        
          return false;
        }
      
          return true;
        })();
      
        errs << "  failed option 1 (VectorKindBigEndian):\n";
        ([&]() {
      
        if (xd::VectorKind::BigEndian != ::llvm::cast<XdVectorType>(resultType)->getKind()) {
          errs << "  inconsistent value of eq:$rhs found\n";
          errs << "  while checking VectorKindBigEndian:\n";
          errs << "    here:       " << printable(xd::VectorKind::BigEndian) << '\n';
          errs << "    previously: " << printable(::llvm::cast<XdVectorType>(resultType)->getKind()) << '\n';
        
          return false;
        }
      
          return true;
        })();
      return false;
}
}

          return true;
        }()) {
          errs << "  while checking (isReasonableVectorKind ?:$kind)\n";
          
      errs << "  with $kind = " << printable(::llvm::cast<XdVectorType>(resultType)->getKind()) << '\n';
    
        
          return false;
        }
        return true;
}


      ::llvm::Value * FromFixedVectorOp::getSource() {
        return getArgOperand(0);
      }

      void FromFixedVectorOp::setSource(::llvm::Value * source) {
        setArgOperand(0, source);
      }
::llvm::Value *FromFixedVectorOp::getResult() {return this;}



      const ::llvm::StringLiteral HandleGetOp::s_name{"xd.handle.get"};

    HandleGetOp* HandleGetOp::create(llvm_dialects::Builder& b) {
    ::llvm::LLVMContext& context = b.getContext();
    (void)context;
    ::llvm::Module& module = *b.GetInsertBlock()->getModule();
  
  
      const ::llvm::AttributeList attrs
          = ExampleDialect::get(context).getAttributeList(1);
    auto fnType = ::llvm::FunctionType::get(XdHandleType::get(context), {
}, false);

    auto fn = module.getOrInsertFunction(s_name, fnType, attrs);
    ::llvm::SmallString<32> newName;
    for (unsigned i = 0; !::llvm::isa<::llvm::Function>(fn.getCallee()) ||
                         ::llvm::cast<::llvm::Function>(fn.getCallee())->getFunctionType() != fn.getFunctionType(); i++) {
      // If a function with the same name but a different types already exists,
      // we get a bitcast of a function or a function with the wrong type.
      // Try new names until we get one with the correct type.
      newName = "";
      ::llvm::raw_svector_ostream newNameStream(newName);
      newNameStream << s_name << "_" << i;
      fn = module.getOrInsertFunction(newNameStream.str(), fnType, attrs);
    }
    assert(::llvm::isa<::llvm::Function>(fn.getCallee()));
    assert(fn.getFunctionType() == fnType);
    assert(::llvm::cast<::llvm::Function>(fn.getCallee())->getFunctionType() == fn.getFunctionType());

  return ::llvm::cast<HandleGetOp>(b.CreateCall(fn));
}


    bool HandleGetOp::verifier(::llvm::raw_ostream &errs) {
      ::llvm::LLVMContext &context = getModule()->getContext();
      (void)context;

      using ::llvm_dialects::printable;

      if (arg_size() != 0) {
        errs << "  wrong number of arguments: " << arg_size()
               << ", expected 0\n";
        return false;
      }
  ::llvm::Type * const resultType = getResult()->getType();
(void)resultType;

        if (XdHandleType::get(context) != resultType) {
          errs << "  unexpected value of $result:\n";
          errs << "    expected:  " << printable(XdHandleType::get(context)) << '\n';
          errs << "    actual:    " << printable(resultType) << '\n';
        
          return false;
        }
        return true;
}


::llvm::Value *HandleGetOp::getResult() {return this;}



      const ::llvm::StringLiteral IExtOp::s_name{"xd.iext"};

    IExtOp* IExtOp::create(llvm_dialects::Builder& b, ::llvm::Type* resultType, ::llvm::Value * source) {
    ::llvm::LLVMContext& context = b.getContext();
    (void)context;
    ::llvm::Module& module = *b.GetInsertBlock()->getModule();
  
  
      const ::llvm::AttributeList attrs
          = ExampleDialect::get(context).getAttributeList(1);
    
      std::string mangledName =
          ::llvm_dialects::getMangledName(s_name, {resultType});
    auto fnType = ::llvm::FunctionType::get(resultType, true);

    auto fn = module.getOrInsertFunction(mangledName, fnType, attrs);
    ::llvm::SmallString<32> newName;
    for (unsigned i = 0; !::llvm::isa<::llvm::Function>(fn.getCallee()) ||
                         ::llvm::cast<::llvm::Function>(fn.getCallee())->getFunctionType() != fn.getFunctionType(); i++) {
      // If a function with the same name but a different types already exists,
      // we get a bitcast of a function or a function with the wrong type.
      // Try new names until we get one with the correct type.
      newName = "";
      ::llvm::raw_svector_ostream newNameStream(newName);
      newNameStream << mangledName << "_" << i;
      fn = module.getOrInsertFunction(newNameStream.str(), fnType, attrs);
    }
    assert(::llvm::isa<::llvm::Function>(fn.getCallee()));
    assert(fn.getFunctionType() == fnType);
    assert(::llvm::cast<::llvm::Function>(fn.getCallee())->getFunctionType() == fn.getFunctionType());

  ::llvm::SmallVector<::llvm::Value*, 1> args = {
source
      };
      
      return ::llvm::cast<IExtOp>(b.CreateCall(fn, args));
    }


    bool IExtOp::verifier(::llvm::raw_ostream &errs) {
      ::llvm::LLVMContext &context = getModule()->getContext();
      (void)context;

      using ::llvm_dialects::printable;

      if (arg_size() != 1) {
        errs << "  wrong number of arguments: " << arg_size()
               << ", expected 1\n";
        return false;
      }
  ::llvm::Type * const sourceType = getSource()->getType();
(void)sourceType;
::llvm::Type * const resultType = getResult()->getType();
(void)resultType;

        if (!(sourceType->isIntegerTy())) {
          errs << "  failed check for (IntegerType (le ?:$result_width)):$source\n";
          
      errs << "  with $source = " << printable(sourceType) << '\n';
    
        
          return false;
        }
      
        if (!(resultType->isIntegerTy())) {
          errs << "  failed check for (IntegerType ?:$result_width):$result\n";
          
      errs << "  with $result = " << printable(resultType) << '\n';
    
        
          return false;
        }
      
        if (!(sourceType->getIntegerBitWidth() <= resultType->getIntegerBitWidth())) {
          errs << "  failed check for (le ?:$result_width):IntegerType:$num_bits\n";
          
      errs << "  with IntegerType:$num_bits = " << printable(sourceType->getIntegerBitWidth()) << '\n';
    
          errs << "  with $result_width = " << printable(resultType->getIntegerBitWidth()) << '\n';
        
        
          return false;
        }
        return true;
}


      ::llvm::Value * IExtOp::getSource() {
        return getArgOperand(0);
      }

      void IExtOp::setSource(::llvm::Value * source) {
        setArgOperand(0, source);
      }
::llvm::Value *IExtOp::getResult() {return this;}



      const ::llvm::StringLiteral ITruncOp::s_name{"xd.itrunc"};

    ITruncOp* ITruncOp::create(llvm_dialects::Builder& b, ::llvm::Type* resultType, ::llvm::Value * source) {
    ::llvm::LLVMContext& context = b.getContext();
    (void)context;
    ::llvm::Module& module = *b.GetInsertBlock()->getModule();
  
  
      const ::llvm::AttributeList attrs
          = ExampleDialect::get(context).getAttributeList(1);
    
      std::string mangledName =
          ::llvm_dialects::getMangledName(s_name, {resultType});
    auto fnType = ::llvm::FunctionType::get(resultType, true);

    auto fn = module.getOrInsertFunction(mangledName, fnType, attrs);
    ::llvm::SmallString<32> newName;
    for (unsigned i = 0; !::llvm::isa<::llvm::Function>(fn.getCallee()) ||
                         ::llvm::cast<::llvm::Function>(fn.getCallee())->getFunctionType() != fn.getFunctionType(); i++) {
      // If a function with the same name but a different types already exists,
      // we get a bitcast of a function or a function with the wrong type.
      // Try new names until we get one with the correct type.
      newName = "";
      ::llvm::raw_svector_ostream newNameStream(newName);
      newNameStream << mangledName << "_" << i;
      fn = module.getOrInsertFunction(newNameStream.str(), fnType, attrs);
    }
    assert(::llvm::isa<::llvm::Function>(fn.getCallee()));
    assert(fn.getFunctionType() == fnType);
    assert(::llvm::cast<::llvm::Function>(fn.getCallee())->getFunctionType() == fn.getFunctionType());

  ::llvm::SmallVector<::llvm::Value*, 1> args = {
source
      };
      
      return ::llvm::cast<ITruncOp>(b.CreateCall(fn, args));
    }


    bool ITruncOp::verifier(::llvm::raw_ostream &errs) {
      ::llvm::LLVMContext &context = getModule()->getContext();
      (void)context;

      using ::llvm_dialects::printable;

      if (arg_size() != 1) {
        errs << "  wrong number of arguments: " << arg_size()
               << ", expected 1\n";
        return false;
      }
  ::llvm::Type * const sourceType = getSource()->getType();
(void)sourceType;
::llvm::Type * const resultType = getResult()->getType();
(void)resultType;

        if (!(sourceType->isIntegerTy())) {
          errs << "  failed check for (IntegerType ?:$source_width):$source\n";
          
      errs << "  with $source = " << printable(sourceType) << '\n';
    
        
          return false;
        }
      
        if (!(resultType->isIntegerTy())) {
          errs << "  failed check for (IntegerType ?:$result_width):$result\n";
          
      errs << "  with $result = " << printable(resultType) << '\n';
    
        
          return false;
        }
      
        if (!(resultType->getIntegerBitWidth() <= sourceType->getIntegerBitWidth())) {
          errs << "  failed check for (le ?:$result_width, ?:$source_width)\n";
          
      errs << "  with $result_width = " << printable(resultType->getIntegerBitWidth()) << '\n';
    
          errs << "  with $source_width = " << printable(sourceType->getIntegerBitWidth()) << '\n';
        
        
          return false;
        }
        return true;
}


      ::llvm::Value * ITruncOp::getSource() {
        return getArgOperand(0);
      }

      void ITruncOp::setSource(::llvm::Value * source) {
        setArgOperand(0, source);
      }
::llvm::Value *ITruncOp::getResult() {return this;}



      const ::llvm::StringLiteral InsertElementOp::s_name{"xd.insertelement"};

    InsertElementOp* InsertElementOp::create(llvm_dialects::Builder& b, ::llvm::Value * vector, ::llvm::Value * value, ::llvm::Value * index) {
    ::llvm::LLVMContext& context = b.getContext();
    (void)context;
    ::llvm::Module& module = *b.GetInsertBlock()->getModule();
  
  
      const ::llvm::AttributeList attrs
          = ExampleDialect::get(context).getAttributeList(1);
    
      std::string mangledName =
          ::llvm_dialects::getMangledName(s_name, {vector->getType()});
    auto fnType = ::llvm::FunctionType::get(vector->getType(), true);

    auto fn = module.getOrInsertFunction(mangledName, fnType, attrs);
    ::llvm::SmallString<32> newName;
    for (unsigned i = 0; !::llvm::isa<::llvm::Function>(fn.getCallee()) ||
                         ::llvm::cast<::llvm::Function>(fn.getCallee())->getFunctionType() != fn.getFunctionType(); i++) {
      // If a function with the same name but a different types already exists,
      // we get a bitcast of a function or a function with the wrong type.
      // Try new names until we get one with the correct type.
      newName = "";
      ::llvm::raw_svector_ostream newNameStream(newName);
      newNameStream << mangledName << "_" << i;
      fn = module.getOrInsertFunction(newNameStream.str(), fnType, attrs);
    }
    assert(::llvm::isa<::llvm::Function>(fn.getCallee()));
    assert(fn.getFunctionType() == fnType);
    assert(::llvm::cast<::llvm::Function>(fn.getCallee())->getFunctionType() == fn.getFunctionType());

  ::llvm::SmallVector<::llvm::Value*, 3> args = {
vector,
value,
index
      };
      
      return ::llvm::cast<InsertElementOp>(b.CreateCall(fn, args));
    }


    bool InsertElementOp::verifier(::llvm::raw_ostream &errs) {
      ::llvm::LLVMContext &context = getModule()->getContext();
      (void)context;

      using ::llvm_dialects::printable;

      if (arg_size() != 3) {
        errs << "  wrong number of arguments: " << arg_size()
               << ", expected 3\n";
        return false;
      }
  ::llvm::Type * const vectorType = getVector()->getType();
(void)vectorType;
::llvm::Type * const valueType = getValue()->getType();
(void)valueType;
::llvm::Type * const indexType = getIndex()->getType();
(void)indexType;
::llvm::Type * const resultType = getResult()->getType();
(void)resultType;

        if (::llvm::IntegerType::get(context, 32) != indexType) {
          errs << "  unexpected value of $index:\n";
          errs << "    expected:  " << printable(::llvm::IntegerType::get(context, 32)) << '\n';
          errs << "    actual:    " << printable(indexType) << '\n';
        
          return false;
        }
      
        if (vectorType != resultType) {
          errs << "  unexpected value of $result:\n";
          errs << "    expected:  " << printable(vectorType) << '\n';
          errs << "    actual:    " << printable(resultType) << '\n';
        
          return false;
        }
      
        if (!(::llvm::isa<XdVectorType>(resultType))) {
          errs << "  failed check for (XdVectorType ?:$result, any, ?:$value, any)\n";
          
      errs << "  with $result = " << printable(resultType) << '\n';
    
        
          return false;
        }
      
        if (::llvm::cast<XdVectorType>(resultType)->getElementType() != valueType) {
          errs << "  unexpected value of $value:\n";
          errs << "    expected:  " << printable(::llvm::cast<XdVectorType>(resultType)->getElementType()) << '\n';
          errs << "    actual:    " << printable(valueType) << '\n';
        
          return false;
        }
        return true;
}


      ::llvm::Value * InsertElementOp::getVector() {
        return getArgOperand(0);
      }

      void InsertElementOp::setVector(::llvm::Value * vector) {
        setArgOperand(0, vector);
      }
      ::llvm::Value * InsertElementOp::getValue() {
        return getArgOperand(1);
      }

      void InsertElementOp::setValue(::llvm::Value * value) {
        setArgOperand(1, value);
      }
      ::llvm::Value * InsertElementOp::getIndex() {
        return getArgOperand(2);
      }

      void InsertElementOp::setIndex(::llvm::Value * index) {
        setArgOperand(2, index);
      }
::llvm::Value *InsertElementOp::getResult() {return this;}



      const ::llvm::StringLiteral ReadOp::s_name{"xd.read"};

    ReadOp* ReadOp::create(llvm_dialects::Builder& b, ::llvm::Type* dataType) {
    ::llvm::LLVMContext& context = b.getContext();
    (void)context;
    ::llvm::Module& module = *b.GetInsertBlock()->getModule();
  
  
      const ::llvm::AttributeList attrs
          = ExampleDialect::get(context).getAttributeList(3);
    
      std::string mangledName =
          ::llvm_dialects::getMangledName(s_name, {dataType});
    auto fnType = ::llvm::FunctionType::get(dataType, {
}, false);

    auto fn = module.getOrInsertFunction(mangledName, fnType, attrs);
    ::llvm::SmallString<32> newName;
    for (unsigned i = 0; !::llvm::isa<::llvm::Function>(fn.getCallee()) ||
                         ::llvm::cast<::llvm::Function>(fn.getCallee())->getFunctionType() != fn.getFunctionType(); i++) {
      // If a function with the same name but a different types already exists,
      // we get a bitcast of a function or a function with the wrong type.
      // Try new names until we get one with the correct type.
      newName = "";
      ::llvm::raw_svector_ostream newNameStream(newName);
      newNameStream << mangledName << "_" << i;
      fn = module.getOrInsertFunction(newNameStream.str(), fnType, attrs);
    }
    assert(::llvm::isa<::llvm::Function>(fn.getCallee()));
    assert(fn.getFunctionType() == fnType);
    assert(::llvm::cast<::llvm::Function>(fn.getCallee())->getFunctionType() == fn.getFunctionType());

  return ::llvm::cast<ReadOp>(b.CreateCall(fn));
}


    bool ReadOp::verifier(::llvm::raw_ostream &errs) {
      ::llvm::LLVMContext &context = getModule()->getContext();
      (void)context;

      using ::llvm_dialects::printable;

      if (arg_size() != 0) {
        errs << "  wrong number of arguments: " << arg_size()
               << ", expected 0\n";
        return false;
      }
  ::llvm::Type * const dataType = getData()->getType();
(void)dataType;
  return true;
}


::llvm::Value *ReadOp::getData() {return this;}



      const ::llvm::StringLiteral SetReadOp::s_name{"xd.set.read"};

    SetReadOp* SetReadOp::create(llvm_dialects::Builder& b, ::llvm::Type* dataType) {
    ::llvm::LLVMContext& context = b.getContext();
    (void)context;
    ::llvm::Module& module = *b.GetInsertBlock()->getModule();
  
  
      const ::llvm::AttributeList attrs
          = ExampleDialect::get(context).getAttributeList(3);
    
      std::string mangledName =
          ::llvm_dialects::getMangledName(s_name, {dataType});
    auto fnType = ::llvm::FunctionType::get(dataType, {
}, false);

    auto fn = module.getOrInsertFunction(mangledName, fnType, attrs);
    ::llvm::SmallString<32> newName;
    for (unsigned i = 0; !::llvm::isa<::llvm::Function>(fn.getCallee()) ||
                         ::llvm::cast<::llvm::Function>(fn.getCallee())->getFunctionType() != fn.getFunctionType(); i++) {
      // If a function with the same name but a different types already exists,
      // we get a bitcast of a function or a function with the wrong type.
      // Try new names until we get one with the correct type.
      newName = "";
      ::llvm::raw_svector_ostream newNameStream(newName);
      newNameStream << mangledName << "_" << i;
      fn = module.getOrInsertFunction(newNameStream.str(), fnType, attrs);
    }
    assert(::llvm::isa<::llvm::Function>(fn.getCallee()));
    assert(fn.getFunctionType() == fnType);
    assert(::llvm::cast<::llvm::Function>(fn.getCallee())->getFunctionType() == fn.getFunctionType());

  return ::llvm::cast<SetReadOp>(b.CreateCall(fn));
}


    bool SetReadOp::verifier(::llvm::raw_ostream &errs) {
      ::llvm::LLVMContext &context = getModule()->getContext();
      (void)context;

      using ::llvm_dialects::printable;

      if (arg_size() != 0) {
        errs << "  wrong number of arguments: " << arg_size()
               << ", expected 0\n";
        return false;
      }
  ::llvm::Type * const dataType = getData()->getType();
(void)dataType;
  return true;
}


::llvm::Value *SetReadOp::getData() {return this;}



      const ::llvm::StringLiteral SetWriteOp::s_name{"xd.set.write"};

    SetWriteOp* SetWriteOp::create(llvm_dialects::Builder& b, ::llvm::Value * data) {
    ::llvm::LLVMContext& context = b.getContext();
    (void)context;
    ::llvm::Module& module = *b.GetInsertBlock()->getModule();
  
  
      const ::llvm::AttributeList attrs
          = ExampleDialect::get(context).getAttributeList(0);
    auto fnType = ::llvm::FunctionType::get(::llvm::Type::getVoidTy(context), true);

    auto fn = module.getOrInsertFunction(s_name, fnType, attrs);
    ::llvm::SmallString<32> newName;
    for (unsigned i = 0; !::llvm::isa<::llvm::Function>(fn.getCallee()) ||
                         ::llvm::cast<::llvm::Function>(fn.getCallee())->getFunctionType() != fn.getFunctionType(); i++) {
      // If a function with the same name but a different types already exists,
      // we get a bitcast of a function or a function with the wrong type.
      // Try new names until we get one with the correct type.
      newName = "";
      ::llvm::raw_svector_ostream newNameStream(newName);
      newNameStream << s_name << "_" << i;
      fn = module.getOrInsertFunction(newNameStream.str(), fnType, attrs);
    }
    assert(::llvm::isa<::llvm::Function>(fn.getCallee()));
    assert(fn.getFunctionType() == fnType);
    assert(::llvm::cast<::llvm::Function>(fn.getCallee())->getFunctionType() == fn.getFunctionType());

  ::llvm::SmallVector<::llvm::Value*, 1> args = {
data
      };
      
      return ::llvm::cast<SetWriteOp>(b.CreateCall(fn, args));
    }


    bool SetWriteOp::verifier(::llvm::raw_ostream &errs) {
      ::llvm::LLVMContext &context = getModule()->getContext();
      (void)context;

      using ::llvm_dialects::printable;

      if (arg_size() != 1) {
        errs << "  wrong number of arguments: " << arg_size()
               << ", expected 1\n";
        return false;
      }
  ::llvm::Type * const dataType = getData()->getType();
(void)dataType;
  return true;
}


      ::llvm::Value * SetWriteOp::getData() {
        return getArgOperand(0);
      }

      void SetWriteOp::setData(::llvm::Value * data) {
        setArgOperand(0, data);
      }



      const ::llvm::StringLiteral SizeOfOp::s_name{"xd.sizeof"};

    SizeOfOp* SizeOfOp::create(llvm_dialects::Builder& b, ::llvm::Type * sizeofType) {
    ::llvm::LLVMContext& context = b.getContext();
    (void)context;
    ::llvm::Module& module = *b.GetInsertBlock()->getModule();
  
  
      const ::llvm::AttributeList attrs
          = ExampleDialect::get(context).getAttributeList(1);
    auto fnType = ::llvm::FunctionType::get(::llvm::IntegerType::get(context, 64), true);

    auto fn = module.getOrInsertFunction(s_name, fnType, attrs);
    ::llvm::SmallString<32> newName;
    for (unsigned i = 0; !::llvm::isa<::llvm::Function>(fn.getCallee()) ||
                         ::llvm::cast<::llvm::Function>(fn.getCallee())->getFunctionType() != fn.getFunctionType(); i++) {
      // If a function with the same name but a different types already exists,
      // we get a bitcast of a function or a function with the wrong type.
      // Try new names until we get one with the correct type.
      newName = "";
      ::llvm::raw_svector_ostream newNameStream(newName);
      newNameStream << s_name << "_" << i;
      fn = module.getOrInsertFunction(newNameStream.str(), fnType, attrs);
    }
    assert(::llvm::isa<::llvm::Function>(fn.getCallee()));
    assert(fn.getFunctionType() == fnType);
    assert(::llvm::cast<::llvm::Function>(fn.getCallee())->getFunctionType() == fn.getFunctionType());

  ::llvm::SmallVector<::llvm::Value*, 1> args = {
::llvm::PoisonValue::get(sizeofType)
      };
      
      return ::llvm::cast<SizeOfOp>(b.CreateCall(fn, args));
    }


    bool SizeOfOp::verifier(::llvm::raw_ostream &errs) {
      ::llvm::LLVMContext &context = getModule()->getContext();
      (void)context;

      using ::llvm_dialects::printable;

      if (arg_size() != 1) {
        errs << "  wrong number of arguments: " << arg_size()
               << ", expected 1\n";
        return false;
      }
  ::llvm::Type * const sizeofType = getSizeofType();
(void)sizeofType;
::llvm::Type * const resultType = getResult()->getType();
(void)resultType;

        if (::llvm::IntegerType::get(context, 64) != resultType) {
          errs << "  unexpected value of $result:\n";
          errs << "    expected:  " << printable(::llvm::IntegerType::get(context, 64)) << '\n';
          errs << "    actual:    " << printable(resultType) << '\n';
        
          return false;
        }
        return true;
}


      ::llvm::Type * SizeOfOp::getSizeofType() {
        return getArgOperand(0)->getType();
      }

      void SizeOfOp::setSizeofType(::llvm::Type * sizeof_type) {
        setArgOperand(0, llvm::PoisonValue::get(sizeof_type));
      }
::llvm::Value *SizeOfOp::getResult() {return this;}



      const ::llvm::StringLiteral StreamAddOp::s_name{"xd.stream.add"};

    StreamAddOp* StreamAddOp::create(llvm_dialects::Builder& b, ::llvm::Value * ptr, ::llvm::Value * count, ::llvm::Value * initial) {
    ::llvm::LLVMContext& context = b.getContext();
    (void)context;
    ::llvm::Module& module = *b.GetInsertBlock()->getModule();
  
  
      const ::llvm::AttributeList attrs
          = ExampleDialect::get(context).getAttributeList(2);
    
      std::string mangledName =
          ::llvm_dialects::getMangledName(s_name, {initial->getType()});
    auto fnType = ::llvm::FunctionType::get(initial->getType(), true);

    auto fn = module.getOrInsertFunction(mangledName, fnType, attrs);
    ::llvm::SmallString<32> newName;
    for (unsigned i = 0; !::llvm::isa<::llvm::Function>(fn.getCallee()) ||
                         ::llvm::cast<::llvm::Function>(fn.getCallee())->getFunctionType() != fn.getFunctionType(); i++) {
      // If a function with the same name but a different types already exists,
      // we get a bitcast of a function or a function with the wrong type.
      // Try new names until we get one with the correct type.
      newName = "";
      ::llvm::raw_svector_ostream newNameStream(newName);
      newNameStream << mangledName << "_" << i;
      fn = module.getOrInsertFunction(newNameStream.str(), fnType, attrs);
    }
    assert(::llvm::isa<::llvm::Function>(fn.getCallee()));
    assert(fn.getFunctionType() == fnType);
    assert(::llvm::cast<::llvm::Function>(fn.getCallee())->getFunctionType() == fn.getFunctionType());

  ::llvm::SmallVector<::llvm::Value*, 3> args = {
ptr,
count,
initial
      };
      
      return ::llvm::cast<StreamAddOp>(b.CreateCall(fn, args));
    }


    bool StreamAddOp::verifier(::llvm::raw_ostream &errs) {
      ::llvm::LLVMContext &context = getModule()->getContext();
      (void)context;

      using ::llvm_dialects::printable;

      if (arg_size() != 3) {
        errs << "  wrong number of arguments: " << arg_size()
               << ", expected 3\n";
        return false;
      }
  ::llvm::Type * const ptrType = getPtr()->getType();
(void)ptrType;
::llvm::Type * const countType = getCount()->getType();
(void)countType;
::llvm::Type * const initialType = getInitial()->getType();
(void)initialType;
::llvm::Type * const resultType = getResult()->getType();
(void)resultType;

        if (::llvm::PointerType::get(context, 0) != ptrType) {
          errs << "  unexpected value of $ptr:\n";
          errs << "    expected:  " << printable(::llvm::PointerType::get(context, 0)) << '\n';
          errs << "    actual:    " << printable(ptrType) << '\n';
        
          return false;
        }
      
        if (::llvm::IntegerType::get(context, 64) != countType) {
          errs << "  unexpected value of $count:\n";
          errs << "    expected:  " << printable(::llvm::IntegerType::get(context, 64)) << '\n';
          errs << "    actual:    " << printable(countType) << '\n';
        
          return false;
        }
      
        if (initialType != resultType) {
          errs << "  unexpected value of $result:\n";
          errs << "    expected:  " << printable(initialType) << '\n';
          errs << "    actual:    " << printable(resultType) << '\n';
        
          return false;
        }
        return true;
}


::llvm::Value *StreamAddOp::getResult() {return this;}



      const ::llvm::StringLiteral StreamMaxOp::s_name{"xd.stream.max"};

    StreamMaxOp* StreamMaxOp::create(llvm_dialects::Builder& b, ::llvm::Value * ptr, ::llvm::Value * count, ::llvm::Value * initial) {
    ::llvm::LLVMContext& context = b.getContext();
    (void)context;
    ::llvm::Module& module = *b.GetInsertBlock()->getModule();
  
  
      const ::llvm::AttributeList attrs
          = ExampleDialect::get(context).getAttributeList(2);
    
      std::string mangledName =
          ::llvm_dialects::getMangledName(s_name, {initial->getType()});
    auto fnType = ::llvm::FunctionType::get(initial->getType(), true);

    auto fn = module.getOrInsertFunction(mangledName, fnType, attrs);
    ::llvm::SmallString<32> newName;
    for (unsigned i = 0; !::llvm::isa<::llvm::Function>(fn.getCallee()) ||
                         ::llvm::cast<::llvm::Function>(fn.getCallee())->getFunctionType() != fn.getFunctionType(); i++) {
      // If a function with the same name but a different types already exists,
      // we get a bitcast of a function or a function with the wrong type.
      // Try new names until we get one with the correct type.
      newName = "";
      ::llvm::raw_svector_ostream newNameStream(newName);
      newNameStream << mangledName << "_" << i;
      fn = module.getOrInsertFunction(newNameStream.str(), fnType, attrs);
    }
    assert(::llvm::isa<::llvm::Function>(fn.getCallee()));
    assert(fn.getFunctionType() == fnType);
    assert(::llvm::cast<::llvm::Function>(fn.getCallee())->getFunctionType() == fn.getFunctionType());

  ::llvm::SmallVector<::llvm::Value*, 3> args = {
ptr,
count,
initial
      };
      
      return ::llvm::cast<StreamMaxOp>(b.CreateCall(fn, args));
    }


    bool StreamMaxOp::verifier(::llvm::raw_ostream &errs) {
      ::llvm::LLVMContext &context = getModule()->getContext();
      (void)context;

      using ::llvm_dialects::printable;

      if (arg_size() != 3) {
        errs << "  wrong number of arguments: " << arg_size()
               << ", expected 3\n";
        return false;
      }
  ::llvm::Type * const ptrType = getPtr()->getType();
(void)ptrType;
::llvm::Type * const countType = getCount()->getType();
(void)countType;
::llvm::Type * const initialType = getInitial()->getType();
(void)initialType;
::llvm::Type * const resultType = getResult()->getType();
(void)resultType;

        if (::llvm::PointerType::get(context, 0) != ptrType) {
          errs << "  unexpected value of $ptr:\n";
          errs << "    expected:  " << printable(::llvm::PointerType::get(context, 0)) << '\n';
          errs << "    actual:    " << printable(ptrType) << '\n';
        
          return false;
        }
      
        if (::llvm::IntegerType::get(context, 64) != countType) {
          errs << "  unexpected value of $count:\n";
          errs << "    expected:  " << printable(::llvm::IntegerType::get(context, 64)) << '\n';
          errs << "    actual:    " << printable(countType) << '\n';
        
          return false;
        }
      
        if (initialType != resultType) {
          errs << "  unexpected value of $result:\n";
          errs << "    expected:  " << printable(initialType) << '\n';
          errs << "    actual:    " << printable(resultType) << '\n';
        
          return false;
        }
        return true;
}


::llvm::Value *StreamMaxOp::getResult() {return this;}



      const ::llvm::StringLiteral StreamMinOp::s_name{"xd.stream.min"};

    StreamMinOp* StreamMinOp::create(llvm_dialects::Builder& b, ::llvm::Value * ptr, ::llvm::Value * count, ::llvm::Value * initial) {
    ::llvm::LLVMContext& context = b.getContext();
    (void)context;
    ::llvm::Module& module = *b.GetInsertBlock()->getModule();
  
  
      const ::llvm::AttributeList attrs
          = ExampleDialect::get(context).getAttributeList(2);
    
      std::string mangledName =
          ::llvm_dialects::getMangledName(s_name, {initial->getType()});
    auto fnType = ::llvm::FunctionType::get(initial->getType(), true);

    auto fn = module.getOrInsertFunction(mangledName, fnType, attrs);
    ::llvm::SmallString<32> newName;
    for (unsigned i = 0; !::llvm::isa<::llvm::Function>(fn.getCallee()) ||
                         ::llvm::cast<::llvm::Function>(fn.getCallee())->getFunctionType() != fn.getFunctionType(); i++) {
      // If a function with the same name but a different types already exists,
      // we get a bitcast of a function or a function with the wrong type.
      // Try new names until we get one with the correct type.
      newName = "";
      ::llvm::raw_svector_ostream newNameStream(newName);
      newNameStream << mangledName << "_" << i;
      fn = module.getOrInsertFunction(newNameStream.str(), fnType, attrs);
    }
    assert(::llvm::isa<::llvm::Function>(fn.getCallee()));
    assert(fn.getFunctionType() == fnType);
    assert(::llvm::cast<::llvm::Function>(fn.getCallee())->getFunctionType() == fn.getFunctionType());

  ::llvm::SmallVector<::llvm::Value*, 3> args = {
ptr,
count,
initial
      };
      
      return ::llvm::cast<StreamMinOp>(b.CreateCall(fn, args));
    }


    bool StreamMinOp::verifier(::llvm::raw_ostream &errs) {
      ::llvm::LLVMContext &context = getModule()->getContext();
      (void)context;

      using ::llvm_dialects::printable;

      if (arg_size() != 3) {
        errs << "  wrong number of arguments: " << arg_size()
               << ", expected 3\n";
        return false;
      }
  ::llvm::Type * const ptrType = getPtr()->getType();
(void)ptrType;
::llvm::Type * const countType = getCount()->getType();
(void)countType;
::llvm::Type * const initialType = getInitial()->getType();
(void)initialType;
::llvm::Type * const resultType = getResult()->getType();
(void)resultType;

        if (::llvm::PointerType::get(context, 0) != ptrType) {
          errs << "  unexpected value of $ptr:\n";
          errs << "    expected:  " << printable(::llvm::PointerType::get(context, 0)) << '\n';
          errs << "    actual:    " << printable(ptrType) << '\n';
        
          return false;
        }
      
        if (::llvm::IntegerType::get(context, 64) != countType) {
          errs << "  unexpected value of $count:\n";
          errs << "    expected:  " << printable(::llvm::IntegerType::get(context, 64)) << '\n';
          errs << "    actual:    " << printable(countType) << '\n';
        
          return false;
        }
      
        if (initialType != resultType) {
          errs << "  unexpected value of $result:\n";
          errs << "    expected:  " << printable(initialType) << '\n';
          errs << "    actual:    " << printable(resultType) << '\n';
        
          return false;
        }
        return true;
}


::llvm::Value *StreamMinOp::getResult() {return this;}



      const ::llvm::StringLiteral WriteOp::s_name{"xd.write"};

    WriteOp* WriteOp::create(llvm_dialects::Builder& b, ::llvm::Value * data) {
    ::llvm::LLVMContext& context = b.getContext();
    (void)context;
    ::llvm::Module& module = *b.GetInsertBlock()->getModule();
  
  
      const ::llvm::AttributeList attrs
          = ExampleDialect::get(context).getAttributeList(0);
    auto fnType = ::llvm::FunctionType::get(::llvm::Type::getVoidTy(context), true);

    auto fn = module.getOrInsertFunction(s_name, fnType, attrs);
    ::llvm::SmallString<32> newName;
    for (unsigned i = 0; !::llvm::isa<::llvm::Function>(fn.getCallee()) ||
                         ::llvm::cast<::llvm::Function>(fn.getCallee())->getFunctionType() != fn.getFunctionType(); i++) {
      // If a function with the same name but a different types already exists,
      // we get a bitcast of a function or a function with the wrong type.
      // Try new names until we get one with the correct type.
      newName = "";
      ::llvm::raw_svector_ostream newNameStream(newName);
      newNameStream << s_name << "_" << i;
      fn = module.getOrInsertFunction(newNameStream.str(), fnType, attrs);
    }
    assert(::llvm::isa<::llvm::Function>(fn.getCallee()));
    assert(fn.getFunctionType() == fnType);
    assert(::llvm::cast<::llvm::Function>(fn.getCallee())->getFunctionType() == fn.getFunctionType());

  ::llvm::SmallVector<::llvm::Value*, 1> args = {
data
      };
      
      return ::llvm::cast<WriteOp>(b.CreateCall(fn, args));
    }


    bool WriteOp::verifier(::llvm::raw_ostream &errs) {
      ::llvm::LLVMContext &context = getModule()->getContext();
      (void)context;

      using ::llvm_dialects::printable;

      if (arg_size() != 1) {
        errs << "  wrong number of arguments: " << arg_size()
               << ", expected 1\n";
        return false;
      }
  ::llvm::Type * const dataType = getData()->getType();
(void)dataType;
  return true;
}


      ::llvm::Value * WriteOp::getData() {
        return getArgOperand(0);
      }

      void WriteOp::setData(::llvm::Value * data) {
        setArgOperand(0, data);
      }



      const ::llvm::StringLiteral WriteVarArgOp::s_name{"xd.write.vararg"};

    WriteVarArgOp* WriteVarArgOp::create(llvm_dialects::Builder& b, ::llvm::Value * data, ::llvm::ArrayRef<::llvm::Value *> args) {
    ::llvm::LLVMContext& context = b.getContext();
    (void)context;
    ::llvm::Module& module = *b.GetInsertBlock()->getModule();
  
  
      const ::llvm::AttributeList attrs
          = ExampleDialect::get(context).getAttributeList(0);
    auto fnType = ::llvm::FunctionType::get(::llvm::Type::getVoidTy(context), true);

    auto fn = module.getOrInsertFunction(s_name, fnType, attrs);
    ::llvm::SmallString<32> newName;
    for (unsigned i = 0; !::llvm::isa<::llvm::Function>(fn.getCallee()) ||
                         ::llvm::cast<::llvm::Function>(fn.getCallee())->getFunctionType() != fn.getFunctionType(); i++) {
      // If a function with the same name but a different types already exists,
      // we get a bitcast of a function or a function with the wrong type.
      // Try new names until we get one with the correct type.
      newName = "";
      ::llvm::raw_svector_ostream newNameStream(newName);
      newNameStream << s_name << "_" << i;
      fn = module.getOrInsertFunction(newNameStream.str(), fnType, attrs);
    }
    assert(::llvm::isa<::llvm::Function>(fn.getCallee()));
    assert(fn.getFunctionType() == fnType);
    assert(::llvm::cast<::llvm::Function>(fn.getCallee())->getFunctionType() == fn.getFunctionType());

  ::llvm::SmallVector<::llvm::Value*, 1> arguments = {
data
      };
      
        arguments.append(args.begin(), args.end());
      
      return ::llvm::cast<WriteVarArgOp>(b.CreateCall(fn, arguments));
    }


    bool WriteVarArgOp::verifier(::llvm::raw_ostream &errs) {
      ::llvm::LLVMContext &context = getModule()->getContext();
      (void)context;

      using ::llvm_dialects::printable;

      if (arg_size() < 1) {
        errs << "  wrong number of arguments: " << arg_size()
               << ", expected at least 1\n";
        return false;
      }
  ::llvm::Type * const dataType = getData()->getType();
(void)dataType;
  return true;
}


      ::llvm::Value * WriteVarArgOp::getData() {
        return getArgOperand(0);
      }

      void WriteVarArgOp::setData(::llvm::Value * data) {
        setArgOperand(0, data);
      }
      ::llvm::iterator_range<::llvm::User::value_op_iterator> WriteVarArgOp::getArgs() {
        return ::llvm::make_range(
            value_op_iterator(arg_begin() + 1),
            value_op_iterator(arg_end()));
      }


} // namespace xd

      template <>
      const ::llvm_dialects::OpDescription &
      ::llvm_dialects::OpDescription::get<xd::Add32Op>() {
        static const ::llvm_dialects::OpDescription desc{false, "xd.add32"};
        return desc;
      }

    
      template <>
      const ::llvm_dialects::OpDescription &
      ::llvm_dialects::OpDescription::get<xd::CombineOp>() {
        static const ::llvm_dialects::OpDescription desc{true, "xd.combine"};
        return desc;
      }

    
      template <>
      const ::llvm_dialects::OpDescription &
      ::llvm_dialects::OpDescription::get<xd::ExtractElementOp>() {
        static const ::llvm_dialects::OpDescription desc{true, "xd.extractelement"};
        return desc;
      }

    
      template <>
      const ::llvm_dialects::OpDescription &
      ::llvm_dialects::OpDescription::get<xd::FromFixedVectorOp>() {
        static const ::llvm_dialects::OpDescription desc{true, "xd.fromfixedvector"};
        return desc;
      }

    
      template <>
      const ::llvm_dialects::OpDescription &
      ::llvm_dialects::OpDescription::get<xd::HandleGetOp>() {
        static const ::llvm_dialects::OpDescription desc{false, "xd.handle.get"};
        return desc;
      }

    
      template <>
      const ::llvm_dialects::OpDescription &
      ::llvm_dialects::OpDescription::get<xd::IExtOp>() {
        static const ::llvm_dialects::OpDescription desc{true, "xd.iext"};
        return desc;
      }

    
      template <>
      const ::llvm_dialects::OpDescription &
      ::llvm_dialects::OpDescription::get<xd::ITruncOp>() {
        static const ::llvm_dialects::OpDescription desc{true, "xd.itrunc"};
        return desc;
      }

    
      template <>
      const ::llvm_dialects::OpDescription &
      ::llvm_dialects::OpDescription::get<xd::InsertElementOp>() {
        static const ::llvm_dialects::OpDescription desc{true, "xd.insertelement"};
        return desc;
      }

    
      template <>
      const ::llvm_dialects::OpDescription &
      ::llvm_dialects::OpDescription::get<xd::ReadOp>() {
        static const ::llvm_dialects::OpDescription desc{true, "xd.read"};
        return desc;
      }

    
      template <>
      const ::llvm_dialects::OpDescription &
      ::llvm_dialects::OpDescription::get<xd::SetReadOp>() {
        static const ::llvm_dialects::OpDescription desc{true, "xd.set.read"};
        return desc;
      }

    
      template <>
      const ::llvm_dialects::OpDescription &
      ::llvm_dialects::OpDescription::get<xd::SetWriteOp>() {
        static const ::llvm_dialects::OpDescription desc{false, "xd.set.write"};
        return desc;
      }

    
      template <>
      const ::llvm_dialects::OpDescription &
      ::llvm_dialects::OpDescription::get<xd::SizeOfOp>() {
        static const ::llvm_dialects::OpDescription desc{false, "xd.sizeof"};
        return desc;
      }

    
      template <>
      const ::llvm_dialects::OpDescription &
      ::llvm_dialects::OpDescription::get<xd::StreamAddOp>() {
        static const ::llvm_dialects::OpDescription desc{true, "xd.stream.add"};
        return desc;
      }

    
      template <>
      const ::llvm_dialects::OpDescription &
      ::llvm_dialects::OpDescription::get<xd::StreamMaxOp>() {
        static const ::llvm_dialects::OpDescription desc{true, "xd.stream.max"};
        return desc;
      }

    
      template <>
      const ::llvm_dialects::OpDescription &
      ::llvm_dialects::OpDescription::get<xd::StreamMinOp>() {
        static const ::llvm_dialects::OpDescription desc{true, "xd.stream.min"};
        return desc;
      }

    
      template <>
      const ::llvm_dialects::OpDescription &
      ::llvm_dialects::OpDescription::get<xd::WriteOp>() {
        static const ::llvm_dialects::OpDescription desc{false, "xd.write"};
        return desc;
      }

    
      template <>
      const ::llvm_dialects::OpDescription &
      ::llvm_dialects::OpDescription::get<xd::WriteVarArgOp>() {
        static const ::llvm_dialects::OpDescription desc{false, "xd.write.vararg"};
        return desc;
      }

    
#endif // GET_DIALECT_DEFS
