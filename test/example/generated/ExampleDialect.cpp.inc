// DO NOT EDIT! This file is automatically generated by llvm-dialects-tblgen.


#ifdef GET_INCLUDES
#undef GET_INCLUDES
#include "llvm-dialects/Dialect/Builder.h"
#include "llvm-dialects/Dialect/OpDescription.h"
#include "llvm-dialects/Dialect/Utils.h"
#include "llvm/IR/InstrTypes.h"

#include "llvm/Support/ModRef.h"

#include "llvm/Support/raw_ostream.h"
#endif // GET_INCLUDES

#ifdef GET_DIALECT_DEFS
#undef GET_DIALECT_DEFS
namespace xd {

    void ExampleDialect::anchor() {}

    ::llvm_dialects::Dialect::Key& ExampleDialect::getKey() {
      static Key s_key;
      return s_key;
    }

    ::llvm_dialects::Dialect* ExampleDialect::make(::llvm::LLVMContext& context) {
      return new ExampleDialect(context);
    }

    ExampleDialect::ExampleDialect(::llvm::LLVMContext& context) : DialectImpl(context) {
  {
  ::llvm::AttrBuilder attrBuilder{context};
attrBuilder.addAttribute(::llvm::Attribute::NoUnwind);
attrBuilder.addAttribute(::llvm::Attribute::WillReturn);
attrBuilder.addMemoryAttr(::llvm::MemoryEffects(::llvm::MemoryEffects::Location::InaccessibleMem, ::llvm::ModRefInfo::Mod));
m_attributeLists[0] = ::llvm::AttributeList::get(context, ::llvm::AttributeList::FunctionIndex, attrBuilder);
}
{
  ::llvm::AttrBuilder attrBuilder{context};
attrBuilder.addAttribute(::llvm::Attribute::NoUnwind);
attrBuilder.addAttribute(::llvm::Attribute::WillReturn);
attrBuilder.addMemoryAttr(::llvm::MemoryEffects::none());
m_attributeLists[1] = ::llvm::AttributeList::get(context, ::llvm::AttributeList::FunctionIndex, attrBuilder);
}
{
  ::llvm::AttrBuilder attrBuilder{context};
attrBuilder.addAttribute(::llvm::Attribute::NoUnwind);
attrBuilder.addMemoryAttr(::llvm::MemoryEffects(::llvm::MemoryEffects::Location::InaccessibleMem, ::llvm::ModRefInfo::ModRef));
m_attributeLists[2] = ::llvm::AttributeList::get(context, ::llvm::AttributeList::FunctionIndex, attrBuilder);
}
}


      ::llvm::Type * XdVectorType::getElementType() const {
        return type_params()[0];
      }

    
      uint32_t XdVectorType::getNumElements() const {
        return int_params()[0];
      }

    XdVectorType* XdVectorType::get(::llvm::Type * elementType, uint32_t numElements) {
::llvm::LLVMContext &ctx = elementType->getContext();
::llvm::Type *types[1] = {
elementType,

    };
    unsigned ints[1] = {
  numElements,

      };

      auto *type = ::llvm::cast<XdVectorType>(::llvm::TargetExtType::get(ctx, s_name, types, ints));
      assert(::llvm_dialects::runTypeVerifier([type](llvm::raw_ostream &errs) {
        return type->verifier(errs);
      }, type));
      return type;
    }
  
    bool XdVectorType::verifier(::llvm::raw_ostream &errs) const {
      ::llvm::LLVMContext &ctx = getContext();
      (void)ctx;

      using ::llvm_dialects::printable;

      if (getNumTypeParameters() != 1) {
        errs << "  wrong number of type parameters\n";
        errs << "    expected: 1\n";
        errs << "      actual: " << getNumTypeParameters() << '\n';
        return false;
      }

      if (getNumIntParameters() != 1) {
        errs << "  wrong number of int parameters\n";
        errs << "    expected: 1\n";
        errs << "      actual: " << getNumIntParameters() << '\n';
        return false;
      }
  auto elementType = getElementType();
(void)elementType;
auto numElements = getNumElements();
(void)numElements;
return true;
}


      const ::llvm::StringLiteral Add32Op::s_name{"xd.add32"};

    Add32Op* Add32Op::create(llvm_dialects::Builder& b, ::llvm::Value * lhs, ::llvm::Value * rhs, uint32_t extra) {
    ::llvm::LLVMContext& context = b.getContext();
    ::llvm::Module& module = *b.GetInsertBlock()->getModule();
  
  
      const ::llvm::AttributeList attrs
          = ExampleDialect::get(context).getAttributeList(1);
    auto fnType = ::llvm::FunctionType::get(::llvm::IntegerType::get(context, 32), {
lhs->getType(),
rhs->getType(),
::llvm::IntegerType::get(context, 32),
}, false);

    auto fn = module.getOrInsertFunction(s_name, fnType, attrs);

  ::llvm::Value* const args[] = {
lhs,
rhs,
 ::llvm::ConstantInt::get(::llvm::IntegerType::get(context, 32), extra) ,

      };

      return ::llvm::cast<Add32Op>(b.CreateCall(fn, args));
    }


    bool Add32Op::verifier(::llvm::raw_ostream &errs) {
      ::llvm::LLVMContext &context = getModule()->getContext();
      (void)context;

      using ::llvm_dialects::printable;

      if (arg_size() != 3) {
        errs << "  wrong number of arguments: " << arg_size()
               << ", expected 3\n";
        return false;
      }
  
        if (getArgOperand(2)->getType() != ::llvm::IntegerType::get(context, 32)) {
          errs << "  argument 2 (extra) has type: "
                 << *getArgOperand(2)->getType() << '\n';
          errs << "  expected: " << *::llvm::IntegerType::get(context, 32) << '\n';
          return false;
        }
      ::llvm::Type * const lhsType = getLhs()->getType();
(void)lhsType;
::llvm::Type * const rhsType = getRhs()->getType();
(void)rhsType;
uint32_t const extra = getExtra();
(void)extra;
::llvm::Type * const resultType = getResult()->getType();
(void)resultType;

        if (::llvm::IntegerType::get(context, 32) != lhsType) {
          errs << "  unexpected value of $lhs:\n";
          errs << "    expected:  " << printable(::llvm::IntegerType::get(context, 32)) << '\n';
          errs << "    actual:    " << printable(lhsType) << '\n';
          return false;
        }
      
        if (::llvm::IntegerType::get(context, 32) != rhsType) {
          errs << "  unexpected value of $rhs:\n";
          errs << "    expected:  " << printable(::llvm::IntegerType::get(context, 32)) << '\n';
          errs << "    actual:    " << printable(rhsType) << '\n';
          return false;
        }
      
        if (::llvm::IntegerType::get(context, 32) != resultType) {
          errs << "  unexpected value of $result:\n";
          errs << "    expected:  " << printable(::llvm::IntegerType::get(context, 32)) << '\n';
          errs << "    actual:    " << printable(resultType) << '\n';
          return false;
        }
        return true;
}


        ::llvm::Value * Add32Op::getLhs() {
          return getArgOperand(0);
        }
      
        ::llvm::Value * Add32Op::getRhs() {
          return getArgOperand(1);
        }
      
        uint32_t Add32Op::getExtra() {
          return  ::llvm::cast<::llvm::ConstantInt>(getArgOperand(2))->getZExtValue() ;
        }
      
::llvm::Value *Add32Op::getResult() {return this;}



      const ::llvm::StringLiteral CombineOp::s_name{"xd.combine"};

    CombineOp* CombineOp::create(llvm_dialects::Builder& b, ::llvm::Value * lhs, ::llvm::Value * rhs) {
    ::llvm::LLVMContext& context = b.getContext();
    ::llvm::Module& module = *b.GetInsertBlock()->getModule();
  
  
      const ::llvm::AttributeList attrs
          = ExampleDialect::get(context).getAttributeList(1);
    
      std::string mangledName =
          ::llvm_dialects::getMangledName(s_name, {lhs->getType()});
    auto fnType = ::llvm::FunctionType::get(lhs->getType(), true);

    auto fn = module.getOrInsertFunction(mangledName, fnType, attrs);

  ::llvm::Value* const args[] = {
lhs,
rhs,

      };

      return ::llvm::cast<CombineOp>(b.CreateCall(fn, args));
    }


    bool CombineOp::verifier(::llvm::raw_ostream &errs) {
      ::llvm::LLVMContext &context = getModule()->getContext();
      (void)context;

      using ::llvm_dialects::printable;

      if (arg_size() != 2) {
        errs << "  wrong number of arguments: " << arg_size()
               << ", expected 2\n";
        return false;
      }
  ::llvm::Type * const lhsType = getLhs()->getType();
(void)lhsType;
::llvm::Type * const rhsType = getRhs()->getType();
(void)rhsType;
::llvm::Type * const resultType = getResult()->getType();
(void)resultType;

        if (resultType != lhsType) {
          errs << "  unexpected value of $lhs:\n";
          errs << "    expected:  " << printable(resultType) << '\n';
          errs << "    actual:    " << printable(lhsType) << '\n';
          return false;
        }
      
        if (resultType != rhsType) {
          errs << "  unexpected value of $rhs:\n";
          errs << "    expected:  " << printable(resultType) << '\n';
          errs << "    actual:    " << printable(rhsType) << '\n';
          return false;
        }
        return true;
}


        ::llvm::Value * CombineOp::getLhs() {
          return getArgOperand(0);
        }
      
        ::llvm::Value * CombineOp::getRhs() {
          return getArgOperand(1);
        }
      
::llvm::Value *CombineOp::getResult() {return this;}



      const ::llvm::StringLiteral ExtractElementOp::s_name{"xd.extractelement"};

    ExtractElementOp* ExtractElementOp::create(llvm_dialects::Builder& b, ::llvm::Value * vector, ::llvm::Value * index) {
    ::llvm::LLVMContext& context = b.getContext();
    ::llvm::Module& module = *b.GetInsertBlock()->getModule();
  
  
      const ::llvm::AttributeList attrs
          = ExampleDialect::get(context).getAttributeList(1);
    
      std::string mangledName =
          ::llvm_dialects::getMangledName(s_name, {::llvm::cast<XdVectorType>(vector->getType())->getElementType()});
    auto fnType = ::llvm::FunctionType::get(::llvm::cast<XdVectorType>(vector->getType())->getElementType(), true);

    auto fn = module.getOrInsertFunction(mangledName, fnType, attrs);

  ::llvm::Value* const args[] = {
vector,
index,

      };

      return ::llvm::cast<ExtractElementOp>(b.CreateCall(fn, args));
    }


    bool ExtractElementOp::verifier(::llvm::raw_ostream &errs) {
      ::llvm::LLVMContext &context = getModule()->getContext();
      (void)context;

      using ::llvm_dialects::printable;

      if (arg_size() != 2) {
        errs << "  wrong number of arguments: " << arg_size()
               << ", expected 2\n";
        return false;
      }
  ::llvm::Type * const vectorType = getVector()->getType();
(void)vectorType;
::llvm::Type * const indexType = getIndex()->getType();
(void)indexType;
::llvm::Type * const resultType = getResult()->getType();
(void)resultType;

        if (::llvm::IntegerType::get(context, 32) != indexType) {
          errs << "  unexpected value of $index:\n";
          errs << "    expected:  " << printable(::llvm::IntegerType::get(context, 32)) << '\n';
          errs << "    actual:    " << printable(indexType) << '\n';
          return false;
        }
      
        if (!(::llvm::isa<XdVectorType>(vectorType))) {
          errs << "  failed check for (XdVectorType ?:$result, any):$vector\n";
          
    errs << "  with $vector = " << printable(vectorType) << '\n';
  
          return false;
        }
      
        if (::llvm::cast<XdVectorType>(vectorType)->getElementType() != resultType) {
          errs << "  unexpected value of $result:\n";
          errs << "    expected:  " << printable(::llvm::cast<XdVectorType>(vectorType)->getElementType()) << '\n';
          errs << "    actual:    " << printable(resultType) << '\n';
          return false;
        }
        return true;
}


        ::llvm::Value * ExtractElementOp::getVector() {
          return getArgOperand(0);
        }
      
        ::llvm::Value * ExtractElementOp::getIndex() {
          return getArgOperand(1);
        }
      
::llvm::Value *ExtractElementOp::getResult() {return this;}



      const ::llvm::StringLiteral FromFixedVectorOp::s_name{"xd.fromfixedvector"};

    FromFixedVectorOp* FromFixedVectorOp::create(llvm_dialects::Builder& b, ::llvm::Value * source) {
    ::llvm::LLVMContext& context = b.getContext();
    ::llvm::Module& module = *b.GetInsertBlock()->getModule();
  
  
      const ::llvm::AttributeList attrs
          = ExampleDialect::get(context).getAttributeList(1);
    
      std::string mangledName =
          ::llvm_dialects::getMangledName(s_name, {XdVectorType::get(::llvm::cast<::llvm::FixedVectorType>(source->getType())->getElementType(), ::llvm::cast<::llvm::FixedVectorType>(source->getType())->getNumElements())});
    auto fnType = ::llvm::FunctionType::get(XdVectorType::get(::llvm::cast<::llvm::FixedVectorType>(source->getType())->getElementType(), ::llvm::cast<::llvm::FixedVectorType>(source->getType())->getNumElements()), true);

    auto fn = module.getOrInsertFunction(mangledName, fnType, attrs);

  ::llvm::Value* const args[] = {
source,

      };

      return ::llvm::cast<FromFixedVectorOp>(b.CreateCall(fn, args));
    }


    bool FromFixedVectorOp::verifier(::llvm::raw_ostream &errs) {
      ::llvm::LLVMContext &context = getModule()->getContext();
      (void)context;

      using ::llvm_dialects::printable;

      if (arg_size() != 1) {
        errs << "  wrong number of arguments: " << arg_size()
               << ", expected 1\n";
        return false;
      }
  ::llvm::Type * const sourceType = getSource()->getType();
(void)sourceType;
::llvm::Type * const resultType = getResult()->getType();
(void)resultType;

        if (!(::llvm::isa<::llvm::FixedVectorType>(sourceType))) {
          errs << "  failed check for (FixedVectorType ?:$scalar_type, ?:$num_elements):$source\n";
          
    errs << "  with $source = " << printable(sourceType) << '\n';
  
          return false;
        }
      
        if (!(::llvm::isa<XdVectorType>(resultType))) {
          errs << "  failed check for (XdVectorType ?:$scalar_type, ?:$num_elements):$result\n";
          
    errs << "  with $result = " << printable(resultType) << '\n';
  
          return false;
        }
      
        if (::llvm::cast<XdVectorType>(resultType)->getElementType() != ::llvm::cast<::llvm::FixedVectorType>(sourceType)->getElementType()) {
          errs << "  unexpected value of $scalar_type:\n";
          errs << "    expected:  " << printable(::llvm::cast<XdVectorType>(resultType)->getElementType()) << '\n';
          errs << "    actual:    " << printable(::llvm::cast<::llvm::FixedVectorType>(sourceType)->getElementType()) << '\n';
          return false;
        }
      
        if (::llvm::cast<XdVectorType>(resultType)->getNumElements() != ::llvm::cast<::llvm::FixedVectorType>(sourceType)->getNumElements()) {
          errs << "  unexpected value of $num_elements:\n";
          errs << "    expected:  " << printable(::llvm::cast<XdVectorType>(resultType)->getNumElements()) << '\n';
          errs << "    actual:    " << printable(::llvm::cast<::llvm::FixedVectorType>(sourceType)->getNumElements()) << '\n';
          return false;
        }
        return true;
}


        ::llvm::Value * FromFixedVectorOp::getSource() {
          return getArgOperand(0);
        }
      
::llvm::Value *FromFixedVectorOp::getResult() {return this;}



      const ::llvm::StringLiteral IExtOp::s_name{"xd.iext"};

    IExtOp* IExtOp::create(llvm_dialects::Builder& b, ::llvm::Type* resultType, ::llvm::Value * source) {
    ::llvm::LLVMContext& context = b.getContext();
    ::llvm::Module& module = *b.GetInsertBlock()->getModule();
  
  
      const ::llvm::AttributeList attrs
          = ExampleDialect::get(context).getAttributeList(1);
    
      std::string mangledName =
          ::llvm_dialects::getMangledName(s_name, {resultType});
    auto fnType = ::llvm::FunctionType::get(resultType, true);

    auto fn = module.getOrInsertFunction(mangledName, fnType, attrs);

  ::llvm::Value* const args[] = {
source,

      };

      return ::llvm::cast<IExtOp>(b.CreateCall(fn, args));
    }


    bool IExtOp::verifier(::llvm::raw_ostream &errs) {
      ::llvm::LLVMContext &context = getModule()->getContext();
      (void)context;

      using ::llvm_dialects::printable;

      if (arg_size() != 1) {
        errs << "  wrong number of arguments: " << arg_size()
               << ", expected 1\n";
        return false;
      }
  ::llvm::Type * const sourceType = getSource()->getType();
(void)sourceType;
::llvm::Type * const resultType = getResult()->getType();
(void)resultType;

        if (!(sourceType->isIntegerTy())) {
          errs << "  failed check for (IntegerType (le ?:$result_width)):$source\n";
          
    errs << "  with $source = " << printable(sourceType) << '\n';
  
          return false;
        }
      
        if (!(resultType->isIntegerTy())) {
          errs << "  failed check for (IntegerType ?:$result_width):$result\n";
          
    errs << "  with $result = " << printable(resultType) << '\n';
  
          return false;
        }
      
        if (!(sourceType->getIntegerBitWidth() <= resultType->getIntegerBitWidth())) {
          errs << "  failed check for (le ?:$result_width):IntegerType:$num_bits\n";
          
    errs << "  with IntegerType:$num_bits = " << printable(sourceType->getIntegerBitWidth()) << '\n';
  
        errs << "  with $result_width = " << printable(resultType->getIntegerBitWidth()) << '\n';
      
          return false;
        }
        return true;
}


        ::llvm::Value * IExtOp::getSource() {
          return getArgOperand(0);
        }
      
::llvm::Value *IExtOp::getResult() {return this;}



      const ::llvm::StringLiteral ITruncOp::s_name{"xd.itrunc"};

    ITruncOp* ITruncOp::create(llvm_dialects::Builder& b, ::llvm::Type* resultType, ::llvm::Value * source) {
    ::llvm::LLVMContext& context = b.getContext();
    ::llvm::Module& module = *b.GetInsertBlock()->getModule();
  
  
      const ::llvm::AttributeList attrs
          = ExampleDialect::get(context).getAttributeList(1);
    
      std::string mangledName =
          ::llvm_dialects::getMangledName(s_name, {resultType});
    auto fnType = ::llvm::FunctionType::get(resultType, true);

    auto fn = module.getOrInsertFunction(mangledName, fnType, attrs);

  ::llvm::Value* const args[] = {
source,

      };

      return ::llvm::cast<ITruncOp>(b.CreateCall(fn, args));
    }


    bool ITruncOp::verifier(::llvm::raw_ostream &errs) {
      ::llvm::LLVMContext &context = getModule()->getContext();
      (void)context;

      using ::llvm_dialects::printable;

      if (arg_size() != 1) {
        errs << "  wrong number of arguments: " << arg_size()
               << ", expected 1\n";
        return false;
      }
  ::llvm::Type * const sourceType = getSource()->getType();
(void)sourceType;
::llvm::Type * const resultType = getResult()->getType();
(void)resultType;

        if (!(sourceType->isIntegerTy())) {
          errs << "  failed check for (IntegerType ?:$source_width):$source\n";
          
    errs << "  with $source = " << printable(sourceType) << '\n';
  
          return false;
        }
      
        if (!(resultType->isIntegerTy())) {
          errs << "  failed check for (IntegerType ?:$result_width):$result\n";
          
    errs << "  with $result = " << printable(resultType) << '\n';
  
          return false;
        }
      
        if (!(resultType->getIntegerBitWidth() <= sourceType->getIntegerBitWidth())) {
          errs << "  failed check for (le ?:$result_width, ?:$source_width)\n";
          
    errs << "  with $result_width = " << printable(resultType->getIntegerBitWidth()) << '\n';
  
        errs << "  with $source_width = " << printable(sourceType->getIntegerBitWidth()) << '\n';
      
          return false;
        }
        return true;
}


        ::llvm::Value * ITruncOp::getSource() {
          return getArgOperand(0);
        }
      
::llvm::Value *ITruncOp::getResult() {return this;}



      const ::llvm::StringLiteral InsertElementOp::s_name{"xd.insertelement"};

    InsertElementOp* InsertElementOp::create(llvm_dialects::Builder& b, ::llvm::Value * vector, ::llvm::Value * value, ::llvm::Value * index) {
    ::llvm::LLVMContext& context = b.getContext();
    ::llvm::Module& module = *b.GetInsertBlock()->getModule();
  
  
      const ::llvm::AttributeList attrs
          = ExampleDialect::get(context).getAttributeList(1);
    
      std::string mangledName =
          ::llvm_dialects::getMangledName(s_name, {vector->getType()});
    auto fnType = ::llvm::FunctionType::get(vector->getType(), true);

    auto fn = module.getOrInsertFunction(mangledName, fnType, attrs);

  ::llvm::Value* const args[] = {
vector,
value,
index,

      };

      return ::llvm::cast<InsertElementOp>(b.CreateCall(fn, args));
    }


    bool InsertElementOp::verifier(::llvm::raw_ostream &errs) {
      ::llvm::LLVMContext &context = getModule()->getContext();
      (void)context;

      using ::llvm_dialects::printable;

      if (arg_size() != 3) {
        errs << "  wrong number of arguments: " << arg_size()
               << ", expected 3\n";
        return false;
      }
  ::llvm::Type * const vectorType = getVector()->getType();
(void)vectorType;
::llvm::Type * const valueType = getValue()->getType();
(void)valueType;
::llvm::Type * const indexType = getIndex()->getType();
(void)indexType;
::llvm::Type * const resultType = getResult()->getType();
(void)resultType;

        if (::llvm::IntegerType::get(context, 32) != indexType) {
          errs << "  unexpected value of $index:\n";
          errs << "    expected:  " << printable(::llvm::IntegerType::get(context, 32)) << '\n';
          errs << "    actual:    " << printable(indexType) << '\n';
          return false;
        }
      
        if (vectorType != resultType) {
          errs << "  unexpected value of $result:\n";
          errs << "    expected:  " << printable(vectorType) << '\n';
          errs << "    actual:    " << printable(resultType) << '\n';
          return false;
        }
      
        if (!(::llvm::isa<XdVectorType>(resultType))) {
          errs << "  failed check for (XdVectorType ?:$result, ?:$value, any)\n";
          
    errs << "  with $result = " << printable(resultType) << '\n';
  
          return false;
        }
      
        if (::llvm::cast<XdVectorType>(resultType)->getElementType() != valueType) {
          errs << "  unexpected value of $value:\n";
          errs << "    expected:  " << printable(::llvm::cast<XdVectorType>(resultType)->getElementType()) << '\n';
          errs << "    actual:    " << printable(valueType) << '\n';
          return false;
        }
        return true;
}


        ::llvm::Value * InsertElementOp::getVector() {
          return getArgOperand(0);
        }
      
        ::llvm::Value * InsertElementOp::getValue() {
          return getArgOperand(1);
        }
      
        ::llvm::Value * InsertElementOp::getIndex() {
          return getArgOperand(2);
        }
      
::llvm::Value *InsertElementOp::getResult() {return this;}



      const ::llvm::StringLiteral ReadOp::s_name{"xd.read"};

    ReadOp* ReadOp::create(llvm_dialects::Builder& b, ::llvm::Type* dataType) {
    ::llvm::LLVMContext& context = b.getContext();
    ::llvm::Module& module = *b.GetInsertBlock()->getModule();
  
  
      const ::llvm::AttributeList attrs
          = ExampleDialect::get(context).getAttributeList(2);
    
      std::string mangledName =
          ::llvm_dialects::getMangledName(s_name, {dataType});
    auto fnType = ::llvm::FunctionType::get(dataType, {
}, false);

    auto fn = module.getOrInsertFunction(mangledName, fnType, attrs);

  return ::llvm::cast<ReadOp>(b.CreateCall(fn));
}


    bool ReadOp::verifier(::llvm::raw_ostream &errs) {
      ::llvm::LLVMContext &context = getModule()->getContext();
      (void)context;

      using ::llvm_dialects::printable;

      if (arg_size() != 0) {
        errs << "  wrong number of arguments: " << arg_size()
               << ", expected 0\n";
        return false;
      }
  ::llvm::Type * const dataType = getData()->getType();
(void)dataType;
  return true;
}


::llvm::Value *ReadOp::getData() {return this;}



      const ::llvm::StringLiteral SizeOfOp::s_name{"xd.sizeof"};

    SizeOfOp* SizeOfOp::create(llvm_dialects::Builder& b, ::llvm::Type * sizeofType) {
    ::llvm::LLVMContext& context = b.getContext();
    ::llvm::Module& module = *b.GetInsertBlock()->getModule();
  
  
      const ::llvm::AttributeList attrs
          = ExampleDialect::get(context).getAttributeList(1);
    auto fnType = ::llvm::FunctionType::get(::llvm::IntegerType::get(context, 64), true);

    auto fn = module.getOrInsertFunction(s_name, fnType, attrs);

  ::llvm::Value* const args[] = {
::llvm::PoisonValue::get(sizeofType),

      };

      return ::llvm::cast<SizeOfOp>(b.CreateCall(fn, args));
    }


    bool SizeOfOp::verifier(::llvm::raw_ostream &errs) {
      ::llvm::LLVMContext &context = getModule()->getContext();
      (void)context;

      using ::llvm_dialects::printable;

      if (arg_size() != 1) {
        errs << "  wrong number of arguments: " << arg_size()
               << ", expected 1\n";
        return false;
      }
  ::llvm::Type * const sizeofType = getSizeofType();
(void)sizeofType;
::llvm::Type * const resultType = getResult()->getType();
(void)resultType;

        if (::llvm::IntegerType::get(context, 64) != resultType) {
          errs << "  unexpected value of $result:\n";
          errs << "    expected:  " << printable(::llvm::IntegerType::get(context, 64)) << '\n';
          errs << "    actual:    " << printable(resultType) << '\n';
          return false;
        }
        return true;
}


        ::llvm::Type * SizeOfOp::getSizeofType() {
          return getArgOperand(0)->getType();
        }
      
::llvm::Value *SizeOfOp::getResult() {return this;}



      const ::llvm::StringLiteral WriteOp::s_name{"xd.write"};

    WriteOp* WriteOp::create(llvm_dialects::Builder& b, ::llvm::Value * data) {
    ::llvm::LLVMContext& context = b.getContext();
    ::llvm::Module& module = *b.GetInsertBlock()->getModule();
  
  
      const ::llvm::AttributeList attrs
          = ExampleDialect::get(context).getAttributeList(0);
    auto fnType = ::llvm::FunctionType::get(::llvm::Type::getVoidTy(context), true);

    auto fn = module.getOrInsertFunction(s_name, fnType, attrs);

  ::llvm::Value* const args[] = {
data,

      };

      return ::llvm::cast<WriteOp>(b.CreateCall(fn, args));
    }


    bool WriteOp::verifier(::llvm::raw_ostream &errs) {
      ::llvm::LLVMContext &context = getModule()->getContext();
      (void)context;

      using ::llvm_dialects::printable;

      if (arg_size() != 1) {
        errs << "  wrong number of arguments: " << arg_size()
               << ", expected 1\n";
        return false;
      }
  ::llvm::Type * const dataType = getData()->getType();
(void)dataType;
  return true;
}


        ::llvm::Value * WriteOp::getData() {
          return getArgOperand(0);
        }
      


} // namespace xd

      template <>
      const ::llvm_dialects::OpDescription &
      ::llvm_dialects::OpDescription::get<xd::Add32Op>() {
        static const ::llvm_dialects::OpDescription desc{false, "xd.add32"};
        return desc;
      }

    
      template <>
      const ::llvm_dialects::OpDescription &
      ::llvm_dialects::OpDescription::get<xd::CombineOp>() {
        static const ::llvm_dialects::OpDescription desc{true, "xd.combine"};
        return desc;
      }

    
      template <>
      const ::llvm_dialects::OpDescription &
      ::llvm_dialects::OpDescription::get<xd::ExtractElementOp>() {
        static const ::llvm_dialects::OpDescription desc{true, "xd.extractelement"};
        return desc;
      }

    
      template <>
      const ::llvm_dialects::OpDescription &
      ::llvm_dialects::OpDescription::get<xd::FromFixedVectorOp>() {
        static const ::llvm_dialects::OpDescription desc{true, "xd.fromfixedvector"};
        return desc;
      }

    
      template <>
      const ::llvm_dialects::OpDescription &
      ::llvm_dialects::OpDescription::get<xd::IExtOp>() {
        static const ::llvm_dialects::OpDescription desc{true, "xd.iext"};
        return desc;
      }

    
      template <>
      const ::llvm_dialects::OpDescription &
      ::llvm_dialects::OpDescription::get<xd::ITruncOp>() {
        static const ::llvm_dialects::OpDescription desc{true, "xd.itrunc"};
        return desc;
      }

    
      template <>
      const ::llvm_dialects::OpDescription &
      ::llvm_dialects::OpDescription::get<xd::InsertElementOp>() {
        static const ::llvm_dialects::OpDescription desc{true, "xd.insertelement"};
        return desc;
      }

    
      template <>
      const ::llvm_dialects::OpDescription &
      ::llvm_dialects::OpDescription::get<xd::ReadOp>() {
        static const ::llvm_dialects::OpDescription desc{true, "xd.read"};
        return desc;
      }

    
      template <>
      const ::llvm_dialects::OpDescription &
      ::llvm_dialects::OpDescription::get<xd::SizeOfOp>() {
        static const ::llvm_dialects::OpDescription desc{false, "xd.sizeof"};
        return desc;
      }

    
      template <>
      const ::llvm_dialects::OpDescription &
      ::llvm_dialects::OpDescription::get<xd::WriteOp>() {
        static const ::llvm_dialects::OpDescription desc{false, "xd.write"};
        return desc;
      }

    
#endif // GET_DIALECT_DEFS
