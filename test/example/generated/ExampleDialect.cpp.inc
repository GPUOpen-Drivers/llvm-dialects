// DO NOT EDIT! This file is automatically generated by llvm-dialects-tblgen.


#ifdef GET_INCLUDES
#undef GET_INCLUDES
#include "llvm-dialects/Dialect/Builder.h"
#include "llvm-dialects/Dialect/OpDescription.h"
#include "llvm-dialects/Dialect/Utils.h"
#include "llvm/IR/InstrTypes.h"

#include "llvm/Support/ModRef.h"

#include "llvm/Support/raw_ostream.h"
#endif // GET_INCLUDES

#ifdef GET_DIALECT_DEFS
#undef GET_DIALECT_DEFS
namespace xd {

    void ExampleDialect::anchor() {}

    ::llvm_dialects::Dialect::Key& ExampleDialect::getKey() {
      static Key s_key;
      return s_key;
    }

    ::llvm_dialects::Dialect* ExampleDialect::make(::llvm::LLVMContext& context) {
      return new ExampleDialect(context);
    }

    ExampleDialect::ExampleDialect(::llvm::LLVMContext& context) : DialectImpl(context) {
  {
  ::llvm::AttrBuilder attrBuilder{context};
attrBuilder.addAttribute(::llvm::Attribute::NoUnwind);
attrBuilder.addAttribute(::llvm::Attribute::WillReturn);
attrBuilder.addMemoryAttr(::llvm::MemoryEffects(::llvm::MemoryEffects::Location::InaccessibleMem, ::llvm::ModRefInfo::Mod));
m_attributeLists[0] = ::llvm::AttributeList::get(context, ::llvm::AttributeList::FunctionIndex, attrBuilder);
}
{
  ::llvm::AttrBuilder attrBuilder{context};
attrBuilder.addAttribute(::llvm::Attribute::NoUnwind);
attrBuilder.addAttribute(::llvm::Attribute::WillReturn);
attrBuilder.addMemoryAttr(::llvm::MemoryEffects::none());
m_attributeLists[1] = ::llvm::AttributeList::get(context, ::llvm::AttributeList::FunctionIndex, attrBuilder);
}
{
  ::llvm::AttrBuilder attrBuilder{context};
attrBuilder.addAttribute(::llvm::Attribute::NoUnwind);
attrBuilder.addMemoryAttr(::llvm::MemoryEffects(::llvm::MemoryEffects::Location::InaccessibleMem, ::llvm::ModRefInfo::ModRef));
m_attributeLists[2] = ::llvm::AttributeList::get(context, ::llvm::AttributeList::FunctionIndex, attrBuilder);
}
}


      const ::llvm::StringLiteral Add32Op::s_name{"xd.add32"};

    Add32Op* Add32Op::create(llvm_dialects::Builder& b, ::llvm::Value * lhs, ::llvm::Value * rhs, uint32_t extra) {
    ::llvm::LLVMContext& context = b.getContext();
    ::llvm::Module& module = *b.GetInsertBlock()->getModule();
  
  
      const ::llvm::AttributeList attrs
          = ExampleDialect::get(context).getAttributeList(1);
    llvm::Type* I32 = ::llvm::Type::getInt32Ty(context);
auto fnType = ::llvm::FunctionType::get(I32, {
lhs->getType(),
rhs->getType(),
I32,
}, false);

    auto fn = module.getOrInsertFunction(s_name, fnType, attrs);

  ::llvm::Value* const args[] = {
lhs,
rhs,
 ::llvm::ConstantInt::get(I32, extra) ,

      };

      return ::llvm::cast<Add32Op>(b.CreateCall(fn, args));
    }


    bool Add32Op::verifier(::llvm::raw_ostream &errs) {
      ::llvm::LLVMContext &context = getModule()->getContext();
      (void)context;

      if (arg_size() != 3) {
        errs << "  wrong number of arguments: " << arg_size()
              << ", expected 3\n";
        return false;
      }
  
        if (!(getLhs()->getType() == ::llvm::Type::getInt32Ty(context))) {
          errs << "  op arg verifier failed: getLhs()->getType() == ::llvm::Type::getInt32Ty(context)\n";
          return false;
        }
      
        if (!(getRhs()->getType() == ::llvm::Type::getInt32Ty(context))) {
          errs << "  op arg verifier failed: getRhs()->getType() == ::llvm::Type::getInt32Ty(context)\n";
          return false;
        }
      
        if (!(getResult()->getType() == ::llvm::Type::getInt32Ty(context))) {
          errs << "  op arg verifier failed: getResult()->getType() == ::llvm::Type::getInt32Ty(context)\n";
          return false;
        }
        return true;
}


        ::llvm::Value * Add32Op::getLhs() {
          return getArgOperand(0);
        }
      
        ::llvm::Value * Add32Op::getRhs() {
          return getArgOperand(1);
        }
      
        uint32_t Add32Op::getExtra() {
          return  ::llvm::cast<::llvm::ConstantInt>(getArgOperand(2))->getZExtValue() ;
        }
      
::llvm::Value* Add32Op::getResult() {return this;}



      const ::llvm::StringLiteral CombineOp::s_name{"xd.combine"};

    CombineOp* CombineOp::create(llvm_dialects::Builder& b, ::llvm::Value * lhs, ::llvm::Value * rhs) {
    ::llvm::LLVMContext& context = b.getContext();
    ::llvm::Module& module = *b.GetInsertBlock()->getModule();
  
  
      const ::llvm::AttributeList attrs
          = ExampleDialect::get(context).getAttributeList(1);
    
      std::string mangledName =
          ::llvm_dialects::getMangledName(s_name, {lhs->getType()});
    auto fnType = ::llvm::FunctionType::get(lhs->getType(), true);

    auto fn = module.getOrInsertFunction(mangledName, fnType, attrs);

  ::llvm::Value* const args[] = {
lhs,
rhs,

      };

      return ::llvm::cast<CombineOp>(b.CreateCall(fn, args));
    }


    bool CombineOp::verifier(::llvm::raw_ostream &errs) {
      ::llvm::LLVMContext &context = getModule()->getContext();
      (void)context;

      if (arg_size() != 2) {
        errs << "  wrong number of arguments: " << arg_size()
              << ", expected 2\n";
        return false;
      }
  
        if (!((::llvm_dialects::areTypesEqual({getLhs()->getType(), getRhs()->getType()})))) {
          errs << "  op verifier failed: (::llvm_dialects::areTypesEqual({getLhs()->getType(), getRhs()->getType()}))\n";
          return false;
        }
      
        if (!((::llvm_dialects::areTypesEqual({getResult()->getType(), getLhs()->getType()})))) {
          errs << "  op verifier failed: (::llvm_dialects::areTypesEqual({getResult()->getType(), getLhs()->getType()}))\n";
          return false;
        }
        return true;
}


        ::llvm::Value * CombineOp::getLhs() {
          return getArgOperand(0);
        }
      
        ::llvm::Value * CombineOp::getRhs() {
          return getArgOperand(1);
        }
      
::llvm::Value* CombineOp::getResult() {return this;}



      const ::llvm::StringLiteral ReadOp::s_name{"xd.read"};

    ReadOp* ReadOp::create(llvm_dialects::Builder& b, ::llvm::Type* dataType) {
    ::llvm::LLVMContext& context = b.getContext();
    ::llvm::Module& module = *b.GetInsertBlock()->getModule();
  
  
      const ::llvm::AttributeList attrs
          = ExampleDialect::get(context).getAttributeList(2);
    
      std::string mangledName =
          ::llvm_dialects::getMangledName(s_name, {dataType});
    auto fnType = ::llvm::FunctionType::get(dataType, {
}, false);

    auto fn = module.getOrInsertFunction(mangledName, fnType, attrs);

  return ::llvm::cast<ReadOp>(b.CreateCall(fn));
}


    bool ReadOp::verifier(::llvm::raw_ostream &errs) {
      ::llvm::LLVMContext &context = getModule()->getContext();
      (void)context;

      if (arg_size() != 0) {
        errs << "  wrong number of arguments: " << arg_size()
              << ", expected 0\n";
        return false;
      }
    return true;
}


::llvm::Value* ReadOp::getData() {return this;}



      const ::llvm::StringLiteral WriteOp::s_name{"xd.write"};

    WriteOp* WriteOp::create(llvm_dialects::Builder& b, ::llvm::Value * data) {
    ::llvm::LLVMContext& context = b.getContext();
    ::llvm::Module& module = *b.GetInsertBlock()->getModule();
  
  
      const ::llvm::AttributeList attrs
          = ExampleDialect::get(context).getAttributeList(0);
    llvm::Type* VoidTy = ::llvm::Type::getVoidTy(context);
auto fnType = ::llvm::FunctionType::get(VoidTy, true);

    auto fn = module.getOrInsertFunction(s_name, fnType, attrs);

  ::llvm::Value* const args[] = {
data,

      };

      return ::llvm::cast<WriteOp>(b.CreateCall(fn, args));
    }


    bool WriteOp::verifier(::llvm::raw_ostream &errs) {
      ::llvm::LLVMContext &context = getModule()->getContext();
      (void)context;

      if (arg_size() != 1) {
        errs << "  wrong number of arguments: " << arg_size()
              << ", expected 1\n";
        return false;
      }
    return true;
}


        ::llvm::Value * WriteOp::getData() {
          return getArgOperand(0);
        }
      


} // namespace xd

      template <>
      const ::llvm_dialects::OpDescription &
      ::llvm_dialects::OpDescription::get<xd::Add32Op>() {
        static const ::llvm_dialects::OpDescription desc{false, "xd.add32"};
        return desc;
      }

    
      template <>
      const ::llvm_dialects::OpDescription &
      ::llvm_dialects::OpDescription::get<xd::CombineOp>() {
        static const ::llvm_dialects::OpDescription desc{true, "xd.combine"};
        return desc;
      }

    
      template <>
      const ::llvm_dialects::OpDescription &
      ::llvm_dialects::OpDescription::get<xd::ReadOp>() {
        static const ::llvm_dialects::OpDescription desc{true, "xd.read"};
        return desc;
      }

    
      template <>
      const ::llvm_dialects::OpDescription &
      ::llvm_dialects::OpDescription::get<xd::WriteOp>() {
        static const ::llvm_dialects::OpDescription desc{false, "xd.write"};
        return desc;
      }

    
#endif // GET_DIALECT_DEFS
