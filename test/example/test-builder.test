; NOTE: Assertions have been autogenerated by utils/update_test_checks.py UTC_ARGS: --tool llvm-dialects-example --include-generated-funcs --check-globals
; NOTE: stdin isn't used by the example program, but the redirect makes the UTC tool happy.
; RUN: llvm-dialects-example - | FileCheck --check-prefixes=CHECK %s

;.
; CHECK: @[[GLOB0:[0-9]+]] = private unnamed_addr constant [13 x i8] c"Hello world!\00", align 1
;.
; CHECK-LABEL: @example(
; CHECK-NEXT:  entry:
; CHECK-NEXT:    [[TMP0:%.*]] = call i32 @xd.read__i32()
; CHECK-NEXT:    [[TMP1:%.*]] = call i64 (...) @xd.sizeof(double poison)
; CHECK-NEXT:    [[TMP2:%.*]] = call i32 (...) @xd.itrunc__i32(i64 [[TMP1]])
; CHECK-NEXT:    [[TMP3:%.*]] = call i32 @xd.add32(i32 [[TMP0]], i32 [[TMP2]], i32 7)
; CHECK-NEXT:    [[TMP4:%.*]] = call i32 (...) @xd.combine__i32(i32 [[TMP3]], i32 [[TMP0]])
; CHECK-NEXT:    [[TMP5:%.*]] = call i64 (...) @xd.iext__i64(i32 [[TMP4]])
; CHECK-NEXT:    call void (...) @xd.write(i64 [[TMP5]])
; CHECK-NEXT:    [[TMP6:%.*]] = call <2 x i32> @xd.read__v2i32()
; CHECK-NEXT:    [[TMP7:%.*]] = call target("xd.vector", i32, 1, 2) (...) @xd.fromfixedvector__txd.vector_i32_1_2t(<2 x i32> [[TMP6]])
; CHECK-NEXT:    [[TMP8:%.*]] = call target("xd.vector", i32, 1, 4) @xd.read__txd.vector_i32_1_4t()
; CHECK-NEXT:    [[TMP9:%.*]] = call i32 (...) @xd.extractelement__i32(target("xd.vector", i32, 1, 4) [[TMP8]], i32 [[TMP0]])
; CHECK-NEXT:    [[TMP10:%.*]] = call i32 (...) @xd.extractelement__i32(target("xd.vector", i32, 1, 4) [[TMP8]], i32 2)
; CHECK-NEXT:    [[TMP11:%.*]] = add i32 [[TMP9]], [[TMP10]]
; CHECK-NEXT:    [[TMP12:%.*]] = call target("xd.vector", i32, 1, 2) (...) @xd.insertelement__txd.vector_i32_1_2t(target("xd.vector", i32, 1, 2) [[TMP7]], i32 [[TMP11]], i32 [[TMP0]])
; CHECK-NEXT:    [[TMP13:%.*]] = call target("xd.vector", i32, 1, 2) (...) @xd.insertelement__txd.vector_i32_1_2t(target("xd.vector", i32, 1, 2) [[TMP12]], i32 [[TMP9]], i32 1)
; CHECK-NEXT:    call void (...) @xd.write(target("xd.vector", i32, 1, 2) [[TMP13]])
; CHECK-NEXT:    [[P1:%.*]] = call ptr @xd.read__p0()
; CHECK-NEXT:    [[P2:%.*]] = call i8 (...) @xd.stream.add__i8(ptr [[P1]], i64 14, i8 0)
; CHECK-NEXT:    call void (...) @xd.write(i8 [[P2]])
; CHECK-NEXT:    call void (...) @xd.write.vararg(i8 [[P2]], ptr [[P1]], i8 [[P2]])
; CHECK-NEXT:    [[TMP14:%.*]] = call target("xd.handle") @xd.handle.get()
; CHECK-NEXT:    [[TMP15:%.*]] = call <2 x i32> @xd.set.read__v2i32()
; CHECK-NEXT:    call void (...) @xd.set.write(target("xd.vector", i32, 1, 2) [[TMP13]])
; CHECK-NEXT:    [[TMP16:%.*]] = call [[TMP0]] @xd.read__s_s()
; CHECK-NEXT:    [[TMP17:%.*]] = call [[TMP1]] @xd.read__s_s_0()
; CHECK-NEXT:    [[TMP18:%.*]] = call [[TMP2]] @xd.read__s_s_1()
; CHECK-NEXT:    call void (...) @xd.write([[TMP0]] [[TMP16]])
; CHECK-NEXT:    call void (...) @xd.write([[TMP1]] [[TMP17]])
; CHECK-NEXT:    call void (...) @xd.write([[TMP2]] [[TMP18]])
; CHECK-NEXT:    [[NAME_OF_LLVM_VALUE:%.*]] = call target("xd.handle") @xd.handle.get()
; CHECK-NEXT:    [[TMP19:%.*]] = call i32 (...) @xd.inst.name.conflict(i32 1)
; CHECK-NEXT:    [[NAME_FOO:%.*]] = call i32 (...) @xd.inst.name.conflict(i32 1)
; CHECK-NEXT:    [[TMP20:%.*]] = call i32 (...) @xd.inst.name.conflict.double(i32 1, i32 2)
; CHECK-NEXT:    [[BAR:%.*]] = call i32 (...) @xd.inst.name.conflict.double(i32 1, i32 2)
; CHECK-NEXT:    [[TMP21:%.*]] = call i32 (...) @xd.inst.name.conflict.varargs(ptr [[P1]], i8 [[P2]])
; CHECK-NEXT:    [[TWO_VARARGS:%.*]] = call i32 (...) @xd.inst.name.conflict.varargs(ptr [[P1]], i8 [[P2]])
; CHECK-NEXT:    [[THREE_VARARGS:%.*]] = call i32 (...) @xd.inst.name.conflict.varargs(ptr [[P1]], i8 [[P2]], i32 3)
; CHECK-NEXT:    [[FOUR_VARARGS:%.*]] = call i32 (...) @xd.inst.name.conflict.varargs(ptr [[P1]], i8 [[P2]], i32 3, i32 4)
; CHECK-NEXT:    call void @xd.string.attr.op(ptr @[[GLOB0:[0-9]+]])
; CHECK-NEXT:    ret void
;
